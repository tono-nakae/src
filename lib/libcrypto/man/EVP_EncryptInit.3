.rn '' }`
''' $RCSfile: EVP_EncryptInit.3,v $$Revision: 1.1 $$Date: 2000/10/04 05:41:29 $
'''
''' $Log: EVP_EncryptInit.3,v $
''' Revision 1.1  2000/10/04 05:41:29  itojun
''' add manpages generated by pod2man.  need fixes here and there.
'''
'''
.de Sh
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp
.if t .sp .5v
.if n .sp
..
.de Ip
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.de Vb
.ft CW
.nf
.ne \\$1
..
.de Ve
.ft R

.fi
..
'''
'''
'''     Set up \*(-- to give an unbreakable dash;
'''     string Tr holds user defined translation string.
'''     Bell System Logo is used as a dummy character.
'''
.tr \(*W-|\(bv\*(Tr
.ie n \{\
.ds -- \(*W-
.ds PI pi
.if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\" diablo 12 pitch
.ds L" ""
.ds R" ""
'''   \*(M", \*(S", \*(N" and \*(T" are the equivalent of
'''   \*(L" and \*(R", except that they are used on ".xx" lines,
'''   such as .IP and .SH, which do another additional levels of
'''   double-quote interpretation
.ds M" """
.ds S" """
.ds N" """""
.ds T" """""
.ds L' '
.ds R' '
.ds M' '
.ds S' '
.ds N' '
.ds T' '
'br\}
.el\{\
.ds -- \(em\|
.tr \*(Tr
.ds L" ``
.ds R" ''
.ds M" ``
.ds S" ''
.ds N" ``
.ds T" ''
.ds L' `
.ds R' '
.ds M' `
.ds S' '
.ds N' `
.ds T' '
.ds PI \(*p
'br\}
.\"	If the F register is turned on, we'll generate
.\"	index entries out stderr for the following things:
.\"		TH	Title 
.\"		SH	Header
.\"		Sh	Subsection 
.\"		Ip	Item
.\"		X<>	Xref  (embedded
.\"	Of course, you have to process the output yourself
.\"	in some meaninful fashion.
.if \nF \{
.de IX
.tm Index:\\$1\t\\n%\t"\\$2"
..
.nr % 0
.rr F
.\}
.TH EVP_EncryptInit 3 "0.9.5a" "22/Jul/100" "OpenSSL"
.UC
.if n .hy 0
.if n .na
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.de CQ          \" put $1 in typewriter font
.ft CW
'if n "\c
'if t \\&\\$1\c
'if n \\&\\$1\c
'if n \&"
\\&\\$2 \\$3 \\$4 \\$5 \\$6 \\$7
'.ft R
..
.\" @(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2
.	\" AM - accent mark definitions
.bd B 3
.	\" fudge factors for nroff and troff
.if n \{\
.	ds #H 0
.	ds #V .8m
.	ds #F .3m
.	ds #[ \f1
.	ds #] \fP
.\}
.if t \{\
.	ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.	ds #V .6m
.	ds #F 0
.	ds #[ \&
.	ds #] \&
.\}
.	\" simple accents for nroff and troff
.if n \{\
.	ds ' \&
.	ds ` \&
.	ds ^ \&
.	ds , \&
.	ds ~ ~
.	ds ? ?
.	ds ! !
.	ds /
.	ds q
.\}
.if t \{\
.	ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.	ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.	ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.	ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.	ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.	ds ? \s-2c\h'-\w'c'u*7/10'\u\h'\*(#H'\zi\d\s+2\h'\w'c'u*8/10'
.	ds ! \s-2\(or\s+2\h'-\w'\(or'u'\v'-.8m'.\v'.8m'
.	ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.	ds q o\h'-\w'o'u*8/10'\s-4\v'.4m'\z\(*i\v'-.4m'\s+4\h'\w'o'u*8/10'
.\}
.	\" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds v \\k:\h'-(\\n(.wu*9/10-\*(#H)'\v'-\*(#V'\*(#[\s-4v\s0\v'\*(#V'\h'|\\n:u'\*(#]
.ds _ \\k:\h'-(\\n(.wu*9/10-\*(#H+(\*(#F*2/3))'\v'-.4m'\z\(hy\v'.4m'\h'|\\n:u'
.ds . \\k:\h'-(\\n(.wu*8/10)'\v'\*(#V*4/10'\z.\v'-\*(#V*4/10'\h'|\\n:u'
.ds 3 \*(#[\v'.2m'\s-2\&3\s0\v'-.2m'\*(#]
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.ds oe o\h'-(\w'o'u*4/10)'e
.ds Oe O\h'-(\w'O'u*4/10)'E
.	\" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.	\" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.	ds : e
.	ds 8 ss
.	ds v \h'-1'\o'\(aa\(ga'
.	ds _ \h'-1'^
.	ds . \h'-1'.
.	ds 3 3
.	ds o a
.	ds d- d\h'-1'\(ga
.	ds D- D\h'-1'\(hy
.	ds th \o'bp'
.	ds Th \o'LP'
.	ds ae ae
.	ds Ae AE
.	ds oe oe
.	ds Oe OE
.\}
.rm #[ #] #H #V #F C
.SH "NAME"
EVP_EncryptInit, EVP_EncryptUpdate, EVP_EncryptFinal \- EVP cipher routines
.SH "LIBRARY"
libcrypto, -lcrypto
.SH "SYNOPSIS"
.PP
.Vb 1
\& #include <openssl/evp.h>
.Ve
.Vb 6
\& void EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
\&         unsigned char *key, unsigned char *iv);
\& void EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
\&         int *outl, unsigned char *in, int inl);
\& void EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,
\&         int *outl);
.Ve
.Vb 6
\& void EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
\&         unsigned char *key, unsigned char *iv);
\& void EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
\&         int *outl, unsigned char *in, int inl);
\& int EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,
\&         int *outl);
.Ve
.Vb 6
\& void EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
\&         unsigned char *key, unsigned char *iv, int enc);
\& void EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
\&         int *outl, unsigned char *in, int inl);
\& int EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,
\&         int *outl);
.Ve
.Vb 1
\& void EVP_CIPHER_CTX_cleanup(EVP_CIPHER_CTX *a);
.Ve
.Vb 3
\& const EVP_CIPHER *EVP_get_cipherbyname(const char *name);
\& #define EVP_get_cipherbynid(a) EVP_get_cipherbyname(OBJ_nid2sn(a))
\& #define EVP_get_cipherbyobj(a) EVP_get_cipherbynid(OBJ_obj2nid(a))
.Ve
.Vb 4
\& #define EVP_CIPHER_nid(e)              ((e)->nid)
\& #define EVP_CIPHER_block_size(e)       ((e)->block_size)
\& #define EVP_CIPHER_key_length(e)       ((e)->key_len)
\& #define EVP_CIPHER_iv_length(e)        ((e)->iv_len)
.Ve
.Vb 7
\& int EVP_CIPHER_type(const EVP_CIPHER *ctx);
\& #define EVP_CIPHER_CTX_cipher(e)       ((e)->cipher)
\& #define EVP_CIPHER_CTX_nid(e)          ((e)->cipher->nid)
\& #define EVP_CIPHER_CTX_block_size(e)   ((e)->cipher->block_size)
\& #define EVP_CIPHER_CTX_key_length(e)   ((e)->cipher->key_len)
\& #define EVP_CIPHER_CTX_iv_length(e)    ((e)->cipher->iv_len)
\& #define EVP_CIPHER_CTX_type(c)         EVP_CIPHER_type(EVP_CIPHER_CTX_cipher(c))
.Ve
.Vb 2
\& int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
\& int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
.Ve
.SH "DESCRIPTION"
The EVP cipher routines are a high level interface to certain
symmetric ciphers.
.PP
\fIEVP_EncryptInit()\fR initialises a cipher context \fBctx\fR for encryption
with cipher \fBtype\fR. \fBtype\fR is normally supplied by a function such
as \fIEVP_des_cbc()\fR . \fBkey\fR is the symmetric key to use and \fBiv\fR is the
IV to use (if necessary), the actual number of bytes used for the
key and IV depends on the cipher. It is possible to set all parameters
to NULL except \fBtype\fR in an initial call and supply the remaining
parameters in subsequent calls. This is normally done when the 
\fIEVP_CIPHER_asn1_to_param()\fR function is called to set the cipher
parameters from an ASN1 AlgorithmIdentifier and the key from a
different source.
.PP
\fIEVP_EncryptUpdate()\fR encrypts \fBinl\fR bytes from the buffer \fBin\fR and
writes the encrypted version to \fBout\fR. This function can be called
multiple times to encrypt successive blocks of data. The amount
of data written depends on the block alignment of the encrypted data:
as a result the amount of data written may be anything from zero bytes
to (inl + cipher_block_size \- 1) so \fBoutl\fR should contain sufficient
room.  The actual number of bytes written is placed in \fBoutl\fR.
.PP
\fIEVP_EncryptFinal()\fR encrypts the \*(L"final\*(R" data, that is any data that
remains in a partial block. It uses the \f(CWNOTES\fR entry in the \fIstandard block padding|\fR manpage (aka PKCS
padding). The encrypted final data is written to \fBout\fR which should
have sufficient space for one cipher block. The number of bytes written
is placed in \fBoutl\fR. After this function is called the encryption operation
is finished and no further calls to \fIEVP_EncryptUpdate()\fR should be made.
.PP
\fIEVP_DecryptInit()\fR, \fIEVP_DecryptUpdate()\fR and \fIEVP_DecryptFinal()\fR are the
corresponding decryption operations. \fIEVP_DecryptFinal()\fR will return an
error code if the final block is not correctly formatted. The parameters
and restrictions are identical to the encryption operations except that
the decrypted data buffer \fBout\fR passed to \fIEVP_DecryptUpdate()\fR should
have sufficient room for (\fBinl\fR + cipher_block_size) bytes unless the
cipher block size is 1 in which case \fBinl\fR bytes is sufficient.
.PP
\fIEVP_CipherInit()\fR, \fIEVP_CipherUpdate()\fR and \fIEVP_CipherFinal()\fR are functions
that can be used for decryption or encryption. The operation performed
depends on the value of the \fBenc\fR parameter. It should be set to 1 for
encryption and 0 for decryption.
.PP
\fIEVP_CIPHER_CTX_cleanup()\fR clears all information from a cipher context.
It should be called after all operations using a cipher are complete
so sensitive information does not remain in memory.
.PP
\fIEVP_get_cipherbyname()\fR, \fIEVP_get_cipherbynid()\fR and \fIEVP_get_cipherbyobj()\fR
return an EVP_CIPHER structure when passed a cipher name, a NID or an
ASN1_OBJECT structure.
.PP
\fIEVP_CIPHER_nid()\fR and \fIEVP_CIPHER_CTX_nid()\fR return the NID of a cipher when
passed an \fBEVP_CIPHER\fR or \fBEVP_CIPHER_CTX\fR structure.  The actual NID
value is an internal value which may not have a corresponding OBJECT
IDENTIFIER.
.PP
\fIEVP_CIPHER_key_length()\fR and \fIEVP_CIPHER_CTX_key_length()\fR return the key
length of a cipher when passed an \fBEVP_CIPHER\fR or \fBEVP_CIPHER_CTX\fR
structure. The constant \fBEVP_MAX_KEY_LENGTH\fR is the maximum key length
for all ciphers.
.PP
\fIEVP_CIPHER_iv_length()\fR and \fIEVP_CIPHER_CTX_iv_length()\fR return the IV
length of a cipher when passed an \fBEVP_CIPHER\fR or \fBEVP_CIPHER_CTX\fR.
It will return zero if the cipher does not use an IV.  The constant
\fBEVP_MAX_IV_LENGTH\fR is the maximum IV length for all ciphers.
.PP
\fIEVP_CIPHER_block_size()\fR and \fIEVP_CIPHER_CTX_block_size()\fR return the block
size of a cipher when passed an \fBEVP_CIPHER\fR or \fBEVP_CIPHER_CTX\fR
structure. The constant \fBEVP_MAX_IV_LENGTH\fR is also the maximum block
length for all ciphers.
.PP
\fIEVP_CIPHER_type()\fR and \fIEVP_CIPHER_CTX_type()\fR return the type of the passed
cipher or context. This \*(L"type\*(R" is the actual NID of the cipher OBJECT
IDENTIFIER as such it ignores the cipher parameters and 40 bit RC2 and
128 bit RC2 have the same NID. If the cipher does not have an object
identifier or does not have ASN1 support this function will return
\fBNID_undef\fR.
.PP
\fIEVP_CIPHER_CTX_cipher()\fR returns the \fBEVP_CIPHER\fR structure when passed
an \fBEVP_CIPHER_CTX\fR structure.
.PP
\fIEVP_CIPHER_param_to_asn1()\fR sets the AlgorithmIdentifier \*(L"parameter\*(R" based
on the passed cipher. This will typically include any parameters and an
IV. The cipher IV (if any) must be set when this call is made. This call
should be made before the cipher is actually \*(L"used\*(R" (before any
\fIEVP_EncryptUpdate()\fR, \fIEVP_DecryptUpdate()\fR calls for example). This function
may fail if the cipher does not have any ASN1 support.
.PP
\fIEVP_CIPHER_asn1_to_param()\fR sets the cipher parameters based on an ASN1
AlgorithmIdentifier \*(L"parameter\*(R". The precise effect depends on the cipher
In the case of RC2, for example, it will set the IV and effective key length.
This function should be called after the base cipher type is set but before
the key is set. For example \fIEVP_CipherInit()\fR will be called with the IV and
key set to NULL, \fIEVP_CIPHER_asn1_to_param()\fR will be called and finally
\fIEVP_CipherInit()\fR again with all parameters except the key set to NULL. It is
possible for this function to fail if the cipher does not have any ASN1 support
or the parameters cannot be set (for example the RC2 effective key length
does not have an \fBEVP_CIPHER\fR structure).
.SH "RETURN VALUES"
\fIEVP_EncryptInit()\fR, \fIEVP_EncryptUpdate()\fR and \fIEVP_EncryptFinal()\fR do not return
values.
.PP
\fIEVP_DecryptInit()\fR and \fIEVP_DecryptUpdate()\fR do not return values.
\fIEVP_DecryptFinal()\fR returns 0 if the decrypt failed or 1 for success.
.PP
\fIEVP_CipherInit()\fR and \fIEVP_CipherUpdate()\fR do not return values.
\fIEVP_CipherFinal()\fR returns 1 for a decryption failure or 1 for success, if
the operation is encryption then it always returns 1.
.PP
\fIEVP_CIPHER_CTX_cleanup()\fR does not return a value.
.PP
\fIEVP_get_cipherbyname()\fR, \fIEVP_get_cipherbynid()\fR and \fIEVP_get_cipherbyobj()\fR
return an \fBEVP_CIPHER\fR structure or NULL on error.
.PP
\fIEVP_CIPHER_nid()\fR and \fIEVP_CIPHER_CTX_nid()\fR return a NID.
.PP
\fIEVP_CIPHER_block_size()\fR and \fIEVP_CIPHER_CTX_block_size()\fR return the block
size.
.PP
\fIEVP_CIPHER_key_length()\fR and \fIEVP_CIPHER_CTX_key_length()\fR return the key
length.
.PP
\fIEVP_CIPHER_iv_length()\fR and \fIEVP_CIPHER_CTX_iv_length()\fR return the IV
length or zero if the cipher does not use an IV.
.PP
\fIEVP_CIPHER_type()\fR and \fIEVP_CIPHER_CTX_type()\fR return the NID of the cipher's
OBJECT IDENTIFIER or NID_undef if it has no defined OBJECT IDENTIFIER.
.PP
\fIEVP_CIPHER_CTX_cipher()\fR returns an \fBEVP_CIPHER\fR structure.
.PP
\fIEVP_CIPHER_param_to_asn1()\fR and \fIEVP_CIPHER_asn1_to_param()\fR return 1 for 
success or zero for failure.
.SH "NOTES"
Where possible the \fBEVP\fR interface to symmetric ciphers should be used in
preference to the low level interfaces. This is because the code then becomes
transparent to the cipher used and much more flexible.
.PP
PKCS padding works by adding \fBn\fR padding bytes of value \fBn\fR to make the total 
length of the encrypted data a multiple of the block size. Padding is always
added so if the data is already a multiple of the block size \fBn\fR will equal
the block size. For example if the block size is 8 and 11 bytes are to be
encrypted then 5 padding bytes of value 5 will be added.
.PP
When decrypting the final block is checked to see if it has the correct form.
.PP
Although the decryption operation can produce an error, it is not a strong
test that the input data or key is correct. A random block has better than
1 in 256 chance of being of the correct format and problems with the
input data earlier on will not produce a final decrypt error.
.SH "BUGS"
The current \fBEVP\fR cipher interface is not as flexible as it should be. Only
certain \*(L"spot\*(R" encryption algorithms can be used for ciphers which have various
parameters associated with them (RC2, RC5 for example) this is inadequate.
.PP
Several of the functions do not return error codes because the software versions
can never fail. This is not true of hardware versions.
.SH "SEE ALSO"
the \fIevp(3)|evp(3)\fR manpage
.SH "HISTORY"

.rn }` ''
.IX Title "EVP_EncryptInit 3"
.IX Name "EVP_EncryptInit, EVP_EncryptUpdate, EVP_EncryptFinal - EVP cipher routines"

.IX Header "NAME"

.IX Header "SYNOPSIS"

.IX Header "DESCRIPTION"

.IX Header "RETURN VALUES"

.IX Header "NOTES"

.IX Header "BUGS"

.IX Header "SEE ALSO"

.IX Header "HISTORY"

