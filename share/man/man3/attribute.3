.\" $NetBSD: attribute.3,v 1.6 2010/12/16 17:50:39 jruoho Exp $
.\"
.\" Copyright (c) 2010 The NetBSD Foundation, Inc.
.\" All rights reserved.
.\"
.\" This code is derived from software contributed to The NetBSD Foundation
.\" by Jukka Ruohonen.
.\"
.\" Redistribution and use in source and binary forms, with or without
.\" modification, are permitted provided that the following conditions
.\" are met:
.\" 1. Redistributions of source code must retain the above copyright
.\"    notice, this list of conditions and the following disclaimer.
.\" 2. Redistributions in binary form must reproduce the above copyright
.\"    notice, this list of conditions and the following disclaimer in the
.\"    documentation and/or other materials provided with the distribution.
.\"
.\" THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
.\" ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
.\" TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
.\" PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
.\" BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
.\" CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
.\" SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
.\" INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
.\" CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
.\" ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
.\" POSSIBILITY OF SUCH DAMAGE.
.\"
.Dd December 16, 2010
.Dt ATTRIBUTE 3
.Os
.Sh NAME
.Nm attribute
.Nd non-standard GCC attribute extensions
.Sh SYNOPSIS
.In sys/cdefs.h
.Pp
.Ic __dead
.Pp
.Ic __pure
.Pp
.Ic __constfunc
.Pp
.Ic __noinline
.Pp
.Ic __unused
.Pp
.Ic __used
.Pp
.Ic __packed
.Pp
.Fn __aligned "x"
.Fn __section "section"
.Sh DESCRIPTION
The
.Tn GNU
Compiler Collection
.Pq Tn GCC
provides many extensions to the standard C language.
Among these are the so-called attributes.
In
.Nx
all attributes are provided in a restricted namespace.
The described macros should be preferred instead of using the
.Tn GCC's
.Em __attribute__
extension directly.
.Sh ATTRIBUTES
.Bl -tag -width abc
.It Ic __dead
The
.Xr gcc 1
compiler knows that certain functions such as
.Xr abort 3
and
.Xr exit 3
can never return any value.
When such a function is equipped with
.Ic __dead ,
certain optimizations are possible.
Obviously a
.Ic __dead
function can never have return type other than
.Vt void .
.It Ic __pure
A
.Ic __pure
function is defined to be one that has no effects except
the return value, which is assumed to depend only on the
function parameters and/or global variables.
Any access to parameters and/or global variables must also be read-only.
A function that depends on volatile memory, or other comparable
system resource that can change between two consecutive calls,
can never be
.Ic __pure .
Many
.Xr math 3
functions satisfy the definition of a
.Ic __pure
function, at least in theory.
Other examples include
.Xr strlen 3
and
.Xr strcmp 3 .
.It Ic __constfunc
A
.Dq const function
is a stricter variant of
.Dq pure functions .
In addition to the restrictions of pure functions, a function declared with
.Ic __constfunc
can never access global variables nor take pointers as parameters.
The return value of these functions must depend
only on the passed-by-value parameters.
Note also that a function that calls non-const functions can not be
.Ic __constfunc .
The canonical example of a const function would be
.Xr abs 3 .
As with pure functions,
certain micro-optimizations are possible for functions declared with
.Ic __constfunc .
.It Ic __noinline
.Tn GCC
is known for aggressive function inlining.
Sometimes it is known that inlining is undesirable or that
a function will perform incorrectly when inlined.
The
.Ic __noinline
macro expands to a function attribute that prevents
.Tn GCC
for inlining the function, irrespective
whether the function was declared with the
.Em inline
keyword.
The attribute takes precedence over all
other compiler options related to inlining.
.It Ic __unused
In most
.Tn GCC
versions the common
.Fl Wall
flag enables warnings produced by functions that are defined but unused.
Marking an unused function with the
.Ic __unused
macro inhibits these warnings.
.It Ic __used
The
.Ic __used
macro expands to an attribute that informs
.Tn GCC
that a static variable or function is to be always retained
in the object file even if it is unreferenced.
.It Ic __packed
The
.Ic __packed
macro expands to an attribute that forces a variable or
structure field to have the smallest possible alignment,
potentially disregarding architecture specific alignment requirements.
The smallest possible alignment is effectively one byte
for variables and one bit for fields.
If specified on a
.Vt struct
or
.Vt union ,
all variables therein are also packed.
The
.Ic __packed
macro is often useful when dealing with data that
is in a particular static format on the disk, wire, or memory.
.It Fn __aligned "x"
The
.Fn __aligned
macro expands to an attribute that specifies the minimum alignment
in bytes for a variable, structure field, or function.
In other words, the specified object should have an alignment of at least
.Fa x
bytes, as opposed to the minimum alignment requirements dictated
by the architecture and the
.Tn ABI .
Possible use cases include:
.Bl -bullet -offset indent
.It
Mixing assembly and C code.
.It
Dealing with hardware that may impose alignment requirements
greater than the architecture itself.
.It
Using instructions that may impose special alignment requirements.
Typical example would be alignment of frequently used objects along
processor cache lines.
.El
.Pp
Note that when used with functions, structures, or structure members,
.Fn __aligned
can only be used to increase the alignment.
If the macro is however used as part of a
.Vt typedef ,
the alignment can both increase and decrease.
Otherwise it is only possible to decrease the alignment
for variables and fields by using the
.Ic __packed
macro.
The effectiveness of
.Fn __aligned
is largely dependent on the linker.
.It Fn __section "section"
The
.Fn __section
macro expands to an attribute that specifies a particular
.Fa section
to which a variable or function should be placed.
Normally the compiler places the generated objects to sections such as
.Dq data
or
.Dq text .
By using
.Fn __section ,
it is possible to override this behavior, perhaps in order to place
some variables into particular sections specific to unique hardware.
Generally the use cases of
.Fn __section
are very limited.
.El
.Sh SEE ALSO
.Xr gcc 1 ,
.Xr __builtin_object_size 3 ,
.Xr cdefs 3 ,
.Xr c 7
.Sh CAVEATS
It goes without saying that portable applications
should steer clear from non-standard extensions specific
to any given compiler.
Even when portability is not a concern,
use these macros sparsely and wisely.
