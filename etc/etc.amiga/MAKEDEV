#!/bin/sh -
#
# Copyright (c) 1990 The Regents of the University of California.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. All advertising materials mentioning features or use of this software
#    must display the following acknowledgement:
#	This product includes software developed by the University of
#	California, Berkeley and its contributors.
# 4. Neither the name of the University nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
#	amiga/MAKEDEV (1/15/94), from:
#
#	hp300/MAKEDEV (1/15/94), from:
#	@(#)MAKEDEV	5.5 (Berkeley) 5/28/91
#
# Device "make" file.  Valid arguments:
#	std	standard devices
#	local	configuration specific devices
# Tapes:
#	st*	SCSI tape
#	tz*	Zeus SCSI Tape
# Disks:
#	sd*	SCSI disks
#	rz*	ZEUS SCSI disks
#	vnd*	"file" pseudo-disks
# Terminal multiplexors:
# Pseudo terminals:
#	pty*	set of 16 master and slave pseudo terminals
# Printers:
#	par*	motherboard parallel port
# Call units:
#	ser*	motherboard serial port
# Special purpose devices:
#	grf*	custom chip (grf0) or Retina (grf1) video
#	mouse*	Amiga mice
#	kbd	Amiga keyboard
#	ite*	terminal emulator interface to grf devices
#	view*	chopps' video views
#	bpf*	Berkeley Packet Filter

PATH=/sbin:/bin/:/usr/bin:/usr/sbin
umask 77
for i
do
case $i in

std)
	mknod console		c 0 0
	mknod drum		c 3 0	; chmod 640 drum ; chgrp kmem drum
	mknod kmem		c 2 1	; chmod 640 kmem ; chgrp kmem kmem
	mknod mem		c 2 0	; chmod 640 mem ; chgrp kmem mem
	mknod reload		c 2 20	; chmod 640 mem ; chgrp kmem mem
	mknod null		c 2 2	; chmod 666 null
	mknod tty		c 1 0	; chmod 666 tty
	mknod klog		c 6 0	; chmod 600 klog
	mknod stdin		c 21 0	; chmod 666 stdin
	mknod stdout		c 21 1	; chmod 666 stdout
	mknod stderr		c 21 2	; chmod 666 stderr
	mkdir fd > /dev/null 2>&1
	(cd fd && eval `echo "" | awk ' BEGIN { \
		for (i = 0; i < 64; i++) \
			printf("mknod %d c 21 %d;", i, i)}'`)
	chown -R bin.bin fd
	chmod 555 fd
	chmod 666 fd/*
	;;

st*|tz*)
	umask 0 ; unit=`expr $i : '.*[^0-9]\([0-9]*\)'`
	case $i in
	tz*) name=tz; blk=8; chr=23;;
	st*) name=st; blk=7; chr=20;;
	esac
	case $unit in
	0|1|2|3|4|5|6|7)
		four=`expr $unit + 4` ; eight=`expr $unit + 8`
		twelve=`expr $unit + 12`; twenty=`expr $unit + 20`
		#
		# block devices don't work so don't make them
		#mknod ${name}${unit}	b $blk $unit
		#mknod ${name}${four}	b $blk $four
		#mknod ${name}${eight}	b $blk $eight
		#mknod ${name}${twelve}	b $blk $twelve
		#mknod n${name}${unit}	b $blk $four ;: sanity w/pdp11 v7
		#mknod n${name}${eight}	b $blk $twelve ;: ditto
		#
		mknod r${name}${unit}	c $chr $unit
		mknod r${name}${four}	c $chr $four
		mknod r${name}${eight}	c $chr $eight
		mknod r${name}${twelve}	c $chr $twelve
		ln r${name}${four} nr${name}${unit} ;: sanity w/pdp11 v7
		ln r${name}${twelve} nr${name}${eight} ;: ditto
		;;
	*)
		echo bad unit for tape in: $1
		;;
	esac
	umask 77
	;;

sd*|rz*|vnd*)
	umask 2 ; unit=`expr $i : '.*[^0-9]\([0-9]*\)'`
	case $i in
	sd*) name=sd; blk=4; chr=8;;
	rz*) name=rz; blk=5; chr=9;;
	vnd*) name=vnd; blk=6; chr=19;;
	esac
	case $unit in
	0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|\
	17|18|19|20|21|22|23|24|25|26|27|28|29|30|31)
		mknod ${name}${unit}c	b $blk `expr $unit '*' 8 + 2`
		mknod r${name}${unit}c	c $chr `expr $unit '*' 8 + 2`
		if [ $name != cd -a $name != vnd ]
		then
		mknod ${name}${unit}a	b $blk `expr $unit '*' 8 + 0`
		mknod ${name}${unit}b	b $blk `expr $unit '*' 8 + 1`
		mknod ${name}${unit}d	b $blk `expr $unit '*' 8 + 3`
		mknod ${name}${unit}e	b $blk `expr $unit '*' 8 + 4`
		mknod ${name}${unit}f	b $blk `expr $unit '*' 8 + 5`
		mknod ${name}${unit}g	b $blk `expr $unit '*' 8 + 6`
		mknod ${name}${unit}h	b $blk `expr $unit '*' 8 + 7`
		mknod r${name}${unit}a	c $chr `expr $unit '*' 8 + 0`
		mknod r${name}${unit}b	c $chr `expr $unit '*' 8 + 1`
		mknod r${name}${unit}d	c $chr `expr $unit '*' 8 + 3`
		mknod r${name}${unit}e	c $chr `expr $unit '*' 8 + 4`
		mknod r${name}${unit}f	c $chr `expr $unit '*' 8 + 5`
		mknod r${name}${unit}g	c $chr `expr $unit '*' 8 + 6`
		mknod r${name}${unit}h	c $chr `expr $unit '*' 8 + 7`
		fi
		chgrp operator ${name}${unit}[a-h] r${name}${unit}[a-h]
		chmod 640 ${name}${unit}[a-h] r${name}${unit}[a-h]
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
	;;

ser*)
	unit=`expr $i : 'ser\(.*\)'`
	case $unit in
	0)
		mknod tty0${unit} c 12 0
		mknod ttym${unit} c 12 128
		;;
	*)
		echo bad unit for ser in: $i
		;;
	esac
	;;


par*)
	unit=`expr $i : 'par\(.*\)'`
	case $unit in
	0)
		mknod par c 11 0
		;;
	*)
		echo bad unit for par in: $i
		;;
	esac
	;;


ite*)
	unit=`expr $i : 'ite\(.*\)'`
	case $unit in
	0|1|2|3)
		mknod ttye${unit} c 13 ${unit}
		;;
	*)
		echo bad unit for ite in: $i
		;;
	esac
	;;

grf*)
	unit=`expr $i : 'grf\(.*\)'`
	case $unit in
	0|1)
		mknod grf${unit} c 10 ${unit}; chmod 666 grf${unit}
		;;
	*)
		echo bad unit for grf in: $i
		;;
	esac
	;;

mouse*)
	unit=`expr $i : 'mouse\(.*\)'`
	case $unit in
	0|1)
		mknod mouse${unit} c 15 ${unit}; chmod 666 mouse${unit}
		;;
	*)
		echo bad unit for mouse in: $i
		;;
	esac
	;;

kbd)
	mknod kbd c 11 0
	;;


view*)
	unit=`expr $i : 'view\(.*\)'`
	case $unit in
	00|01|02|03|04|05|06|07|08|09)
		mknod view${unit} c 16 ${unit}; chmod 666 view${unit}
		;;
	*)
		echo bad unit for view in: $i
		;;
	esac
	;;

pty*)
	class=`expr $i : 'pty\(.*\)'`
	case $class in
	0) offset=0 name=p;;
	1) offset=16 name=q;;
	2) offset=32 name=r;;
	3) offset=48 name=s;;
# Note that telnetd, rlogind, and xterm (at least) only look at p-s.
	4) offset=64 name=t;;
	*) echo bad unit for pty in: $i;;
	esac
	case $class in
	0|1|2|3|4)
		umask 0
		eval `echo $offset $name | awk ' { b=$1; n=$2 } END {
			for (i = 0; i < 16; i++)
				printf("mknod tty%s%x c 4 %d; \
					mknod pty%s%x c 5 %d; ", \
					n, i, b+i, n, i, b+i); }'`
		umask 77
		if [ $class = 1 ]; then
			mv ttyqf ttyv0; mv ptyqf ptyv0
		fi
		;;
	esac
	;;

bpf*)
	unit=`expr $i : 'bpf\(.*\)'`
	rm -f bpf$unit
	mknod bpf$unit c 22 $unit
	chown root.wheel bpf$unit
	;;

local)
	umask 0
	sh MAKEDEV.local
	;;
*)
	echo $i: unknown device
	;;
esac
done
---snip snip---

-- 
Ty Sarna                 "As you know, Joel, children have always looked
tsarna@endicor.com        up to cowboys as role models. And vice versa."

>From postmaster@cbmuucp.commodore.com  Sun Jan 23 23:45:57 1994
Received: from cbmmail.commodore.com by chsun.eunet.ch (8.6.4/1.34)
	id XAA23930; Sun, 23 Jan 1994 23:45:51 +0100
Received: from cbmuucp.commodore.com by cbmmail.commodore.com (4.1/SMI-4.1)
	id AA23292; Sun, 23 Jan 94 17:32:50 EST
Received: by cbmuucp.commodore.com (4.1/SMI-4.1)
	id AA10514; Sun, 23 Jan 94 17:32:45 EST
Received: from cbmmail.commodore.com by cbmuucp.commodore.com (4.1/SMI-4.1)
	id AA10509; Sun, 23 Jan 94 17:32:42 EST
Received: from dptspd.sat.datapoint.com by cbmmail.commodore.com (4.1/SMI-4.1)
	id AA23289; Sun, 23 Jan 94 17:32:37 EST
Received: from endicor.com by dptspd.sat.datapoint.com with uucp
	(Smail3.1.28.1 #2) id m0pODMC-0000ThC; Sun, 23 Jan 94 16:32 CST
Received: by fezzik.endicor.com (5.67b/IDA-1.5)
	id AA03861; Sun, 23 Jan 1994 16:15:12 -0600
To: NetBSD-Dev@cbmuucp.commodore.com
Newsgroups: endicor.lists.netbsd.amiga.devel
From: tsarna@endicor.com (Ty Sarna)
Subject: Re: Another update to MAKEDEV
Message-Id: <CK3sCs.2y3@endicor.com>
Organization: Endicor Technologies, Inc., San Antonio, Texas
References: <199401231906.UAA05303@eunet.ch>
Date: Sun, 23 Jan 1994 22:12:27 GMT
Sender: postmaster@cbmuucp.commodore.com
Status: RO

In article <199401231906.UAA05303@eunet.ch> mw@eunet.ch writes:
> >   My point was that sd0a is minor number 0, sd1a is minor number 8, ...,
> > and sd7a is minor number 56.  Defining sd8a would generate a minor
> > number of 64, which actually refers to device sd0i - the first ados
> > partition.
> 
> That is correct, but it doesn't make sense to talk of sd8a anyway, there's 
> 7 units plus the controller on an scsi bus.

I believe this was meant (on the hp300) to mean unit 0 of the second
SCSI controller. I copied the st and sd sections verbatim from the hp300
MAKEDEV, which is why they are the way they are.


Here's YAUM (Yet Another Updated MAKEDEV).

In this one, I:

- renamed and split "std" into "misc" and "devfd".

- renamed "all" to "std". "all" was somewhat of a misnomer, so "std" now
  follows the SunOS (well, pre-Solaris at least)  behaviour of making all
  standard devices.

- changed st* to support only 4 devices, per MH's suggestion.

- split sd* off from vnd* and changed it to support only units 0-7 (only
  0-6 are made by "std", since 7 is normally the controller) 

- changed sd* to make ados partitions i-p also. Someonee please verify
  that it does thi correctly.

- tested it by building a new /dev from scratch with "std". Seems to
  work fine.

#!/bin/sh -
#
# Copyright (c) 1990 The Regents of the University of California.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. All advertising materials mentioning features or use of this software
#    must display the following acknowledgement:
#	This product includes software developed by the University of
#	California, Berkeley and its contributors.
# 4. Neither the name of the University nor the names of its contributors
#    may be used to endorse or promote products derived from this software
#    without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
#	$Id: MAKEDEV,v 1.1 1994/02/04 20:39:18 deraadt Exp $
#
#	from:
#
#	hp300/MAKEDEV (1/15/94), from:
#	@(#)MAKEDEV	5.5 (Berkeley) 5/28/91
#
# Device "make" file.  Valid arguments:
#	std	all standard devices
#	misc	misc devices
#	local	configuration specific devices
# Tapes:
#	st*	SCSI tape
# Disks:
#	sd*	SCSI disks
#	vnd*	"file" pseudo-disks
# Terminal multiplexors:
# Pseudo terminals:
#	pty*	sets of 16 master and slave pseudo terminals
# Printers:
#	par*	motherboard parallel port
# Call units:
#	ser*	motherboard serial port
# Special purpose devices:
#	devfd	/dev/fd pseudo-device
#	grf*	custom chip (grf0) or Retina (grf1) video
#	mouse*	Amiga mice
#	kbd	Amiga keyboard
#	ite*	terminal emulator interface to grf devices
#	view*	chopps' video views
#	aconf	AUTOCONFIG(TM) information
#	bpf*	Berkeley Packet Filter

PATH=/sbin:/bin/:/usr/bin:/usr/sbin
umask 77
for i
do
case $i in

std)
	$0 misc devfd local
	$0 st0 st1
	$0 sd0 sd1 sd2 sd3 sd4 sd5 sd6
	$0 pty0 ser0 par0
	$0 grf0 grf1 kbd mouse0 mouse1 ite0 ite1 aconf
	$0 view00 view01 view02 view03 view04
	$0 view05 view06 view07 view08 view09
	;;

misc)
	mknod console		c 0 0
	mknod drum		c 3 0	; chmod 640 drum ; chgrp kmem drum
	mknod kmem		c 2 1	; chmod 640 kmem ; chgrp kmem kmem
	mknod mem		c 2 0	; chmod 640 mem ; chgrp kmem mem
	mknod reload		c 2 20	; chmod 640 mem ; chgrp kmem mem
	mknod null		c 2 2	; chmod 666 null
	mknod tty		c 1 0	; chmod 666 tty
	mknod klog		c 6 0	; chmod 600 klog
	;;

devfd)	
	mknod stdin		c 21 0	; chmod 666 stdin
	mknod stdout		c 21 1	; chmod 666 stdout
	mknod stderr		c 21 2	; chmod 666 stderr
	mkdir fd > /dev/null 2>&1
	(cd fd && eval `echo "" | awk ' BEGIN { \
		for (i = 0; i < 64; i++) \
			printf("mknod %d c 21 %d;", i, i)}'`)
	chown -R bin.bin fd
	chmod 555 fd
	chmod 666 fd/*
	;;
	
st*)
	umask 0 ; unit=`expr $i : '.*[^0-9]\([0-9]*\)'`
	case $i in
	st*) name=st; blk=7; chr=20;;
	esac
	case $unit in
	0|1|2|3)
		four=`expr $unit + 4` ; eight=`expr $unit + 8`
		twelve=`expr $unit + 12`; twenty=`expr $unit + 20`
		#
		# block devices don't work so don't make them
		#mknod ${name}${unit}	b $blk $unit
		#mknod ${name}${four}	b $blk $four
		#mknod ${name}${eight}	b $blk $eight
		#mknod ${name}${twelve}	b $blk $twelve
		#mknod n${name}${unit}	b $blk $four ;: sanity w/pdp11 v7
		#mknod n${name}${eight}	b $blk $twelve ;: ditto
		#
		mknod r${name}${unit}	c $chr $unit
		mknod r${name}${four}	c $chr $four
		mknod r${name}${eight}	c $chr $eight
		mknod r${name}${twelve}	c $chr $twelve
		ln r${name}${four} nr${name}${unit} ;: sanity w/pdp11 v7
		ln r${name}${twelve} nr${name}${eight} ;: ditto
		;;
	*)
		echo bad unit for tape in: $1
		;;
	esac
	umask 77
	;;

sd*)
	umask 2 ; unit=`expr $i : '.*[^0-9]\([0-9]*\)'`
	case $i in
	sd*) name=sd; blk=4; chr=8;;
	esac
	case $unit in
	0|1|2|3|4|5|6|7)
		# bsd block devices
		mknod ${name}${unit}a	b $blk `expr $unit '*' 8 + 0`
		mknod ${name}${unit}b	b $blk `expr $unit '*' 8 + 1`
		mknod ${name}${unit}c	b $blk `expr $unit '*' 8 + 2`
		mknod ${name}${unit}d	b $blk `expr $unit '*' 8 + 3`
		mknod ${name}${unit}e	b $blk `expr $unit '*' 8 + 4`
		mknod ${name}${unit}f	b $blk `expr $unit '*' 8 + 5`
		mknod ${name}${unit}g	b $blk `expr $unit '*' 8 + 6`
		mknod ${name}${unit}h	b $blk `expr $unit '*' 8 + 7`

		# ados block devices
		mknod ${name}${unit}i	b $blk `expr $unit '*' 8 + 8 + 0`
		mknod ${name}${unit}j	b $blk `expr $unit '*' 8 + 8 + 1`
		mknod ${name}${unit}k	b $blk `expr $unit '*' 8 + 8 + 2`
		mknod ${name}${unit}l	b $blk `expr $unit '*' 8 + 8 + 3`
		mknod ${name}${unit}m	b $blk `expr $unit '*' 8 + 8 + 4`
		mknod ${name}${unit}n	b $blk `expr $unit '*' 8 + 8 + 5`
		mknod ${name}${unit}o	b $blk `expr $unit '*' 8 + 8 + 6`
		mknod ${name}${unit}p	b $blk `expr $unit '*' 8 + 8 + 7`

		# bsd character devices
		mknod r${name}${unit}a	c $chr `expr $unit '*' 8 + 0`
		mknod r${name}${unit}b	c $chr `expr $unit '*' 8 + 1`
		mknod r${name}${unit}c	c $chr `expr $unit '*' 8 + 2`
		mknod r${name}${unit}d	c $chr `expr $unit '*' 8 + 3`
		mknod r${name}${unit}e	c $chr `expr $unit '*' 8 + 4`
		mknod r${name}${unit}f	c $chr `expr $unit '*' 8 + 5`
		mknod r${name}${unit}g	c $chr `expr $unit '*' 8 + 6`
		mknod r${name}${unit}h	c $chr `expr $unit '*' 8 + 7`

		# ados character devices
		mknod r${name}${unit}i	c $chr `expr $unit '*' 8 + 8 + 0`
		mknod r${name}${unit}j	c $chr `expr $unit '*' 8 + 8 + 1`
		mknod r${name}${unit}k	c $chr `expr $unit '*' 8 + 8 + 2`
		mknod r${name}${unit}l	c $chr `expr $unit '*' 8 + 8 + 3`
		mknod r${name}${unit}m	c $chr `expr $unit '*' 8 + 8 + 4`
		mknod r${name}${unit}n	c $chr `expr $unit '*' 8 + 8 + 5`
		mknod r${name}${unit}o	c $chr `expr $unit '*' 8 + 8 + 6`
		mknod r${name}${unit}p	c $chr `expr $unit '*' 8 + 8 + 7`

		chgrp operator ${name}${unit}[a-p] r${name}${unit}[a-p]
		chmod 640 ${name}${unit}[a-p] r${name}${unit}[a-p]
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
	;;

vnd*)
	umask 2 ; unit=`expr $i : '.*[^0-9]\([0-9]*\)'`
	case $i in
	vnd*) name=vnd; blk=6; chr=19;;
	esac
	case $unit in
	0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|\
	17|18|19|20|21|22|23|24|25|26|27|28|29|30|31)
		mknod ${name}${unit}c	b $blk `expr $unit '*' 8 + 2`
		mknod r${name}${unit}c	c $chr `expr $unit '*' 8 + 2`
		if [ $name != cd -a $name != vnd ]
		then
		mknod ${name}${unit}a	b $blk `expr $unit '*' 8 + 0`
		mknod ${name}${unit}b	b $blk `expr $unit '*' 8 + 1`
		mknod ${name}${unit}d	b $blk `expr $unit '*' 8 + 3`
		mknod ${name}${unit}e	b $blk `expr $unit '*' 8 + 4`
		mknod ${name}${unit}f	b $blk `expr $unit '*' 8 + 5`
		mknod ${name}${unit}g	b $blk `expr $unit '*' 8 + 6`
		mknod ${name}${unit}h	b $blk `expr $unit '*' 8 + 7`
		mknod r${name}${unit}a	c $chr `expr $unit '*' 8 + 0`
		mknod r${name}${unit}b	c $chr `expr $unit '*' 8 + 1`
		mknod r${name}${unit}d	c $chr `expr $unit '*' 8 + 3`
		mknod r${name}${unit}e	c $chr `expr $unit '*' 8 + 4`
		mknod r${name}${unit}f	c $chr `expr $unit '*' 8 + 5`
		mknod r${name}${unit}g	c $chr `expr $unit '*' 8 + 6`
		mknod r${name}${unit}h	c $chr `expr $unit '*' 8 + 7`
		fi
		chgrp operator ${name}${unit}[a-h] r${name}${unit}[a-h]
		chmod 640 ${name}${unit}[a-h] r${name}${unit}[a-h]
		;;
	*)
		echo bad unit for disk in: $i
		;;
	esac
	umask 77
	;;

ser*)
	unit=`expr $i : 'ser\(.*\)'`
	case $unit in
	0)
		mknod tty0${unit} c 12 0
		mknod ttym${unit} c 12 128
		;;
	*)
		echo bad unit for ser in: $i
		;;
	esac
	;;


par*)
	unit=`expr $i : 'par\(.*\)'`
	case $unit in
	0)
		mknod par c 11 0
		;;
	*)
		echo bad unit for par in: $i
		;;
	esac
	;;


ite*)
	unit=`expr $i : 'ite\(.*\)'`
	case $unit in
	0|1|2|3)
		mknod ttye${unit} c 13 ${unit}
		;;
	*)
		echo bad unit for ite in: $i
		;;
	esac
	;;

grf*)
	unit=`expr $i : 'grf\(.*\)'`
	case $unit in
	0|1)
		mknod grf${unit} c 10 ${unit}; chmod 666 grf${unit}
		;;
	*)
		echo bad unit for grf in: $i
		;;
	esac
	;;

mouse*)
	unit=`expr $i : 'mouse\(.*\)'`
	case $unit in
	0|1)
		mknod mouse${unit} c 15 ${unit}; chmod 666 mouse${unit}
		;;
	*)
		echo bad unit for mouse in: $i
		;;
	esac
	;;

kbd)
	mknod kbd c 11 0
	;;


view*)
	unit=`expr $i : 'view\(.*\)'`
	case $unit in
	00|01|02|03|04|05|06|07|08|09)
		mknod view${unit} c 16 ${unit}; chmod 666 view${unit}
		;;
	*)
		echo bad unit for view in: $i
		;;
	esac
	;;

pty*)
	class=`expr $i : 'pty\(.*\)'`
	case $class in
	0) offset=0 name=p;;
	1) offset=16 name=q;;
	2) offset=32 name=r;;
	3) offset=48 name=s;;
# Note that telnetd, rlogind, and xterm (at least) only look at p-s.
	4) offset=64 name=t;;
	*) echo bad unit for pty in: $i;;
	esac
	case $class in
	0|1|2|3|4)
		umask 0
		eval `echo $offset $name | awk ' { b=$1; n=$2 } END {
			for (i = 0; i < 16; i++)
				printf("mknod tty%s%x c 4 %d; \
					mknod pty%s%x c 5 %d; ", \
					n, i, b+i, n, i, b+i); }'`
		umask 77
		if [ $class = 1 ]; then
			mv ttyqf ttyv0; mv ptyqf ptyv0
		fi
		;;
	esac
	;;

aconf)
	mknod autoconfig c 18 0 ; chmod 644 autoconfig
	;;

bpf*)
	unit=`expr $i : 'bpf\(.*\)'`
	rm -f bpf$unit
	mknod bpf$unit c 22 $unit
	chown root.wheel bpf$unit
	;;

local)
	umask 0
	sh MAKEDEV.local
	;;

*)
	echo $i: unknown device
	;;
esac
done
