#	$NetBSD: rc,v 1.80 1997/07/10 13:43:14 drochner Exp $
#	originally from: @(#)rc	8.2 (Berkeley) 3/17/94

# System startup script run by init on autoboot
# or after single-user.
# Output and error are redirected to console by init,
# and the console is the controlling terminal.

stty status '^T'

# Set shell to ignore SIGINT (2), but not children;
# shell catches SIGQUIT (3) and returns to single user after fsck.
trap : 2
trap : 3	# shouldn't be needed

export HOME=/
export PATH=/sbin:/bin:/usr/sbin:/usr/bin

# Configure ccd devices.
if [ -f /etc/ccd.conf ]; then
	ccdconfig -C
fi

# Add all block-type swap devices; these might be necessary
# during disk checks.
swapctl -A -t blk

if [ -e /fastboot ]; then
	echo "Fast boot: skipping disk checks."
elif [ "$1" = autoboot ]; then
	echo "Automatic boot in progress: starting file system checks."
	fsck -p
	case $? in
	0)
		;;
	2)
		exit 1
		;;
	4)
		echo "Rebooting..."
		reboot
		echo "Reboot failed; help!"
		exit 1
		;;
	8)
		echo "Automatic file system check failed; help!"
		exit 1
		;;
	12)
		echo "Boot interrupted."
		exit 1
		;;
	130)
		# interrupt before catcher installed
		exit 1
		;;
	*)
		echo "Unknown error; help!"
		exit 1
		;;
	esac
fi

trap "echo 'Boot interrupted.'; exit 1" 3

umount -a >/dev/null 2>&1
mount /
rm -f /fastboot		# XXX (root now writeable)

if [ -f /etc/rc.conf ]; then
	. /etc/rc.conf
fi

# set flags on ttys.  (do early, in case they use tty for SLIP in netstart)
echo 'setting tty flags'
ttyflags -a

# load any kernel modules specified in /etc/lkm.conf
if [ "$lkm_init" != NO ] && [ -f /etc/rc.lkm ]; then
	. /etc/rc.lkm
fi

# set hostname, turn on network
echo 'starting network'
sh /etc/netstart
if [ $? -ne 0 ]; then
	exit 1
fi

mount /usr >/dev/null 2>&1
mount /var >/dev/null 2>&1

# "Critical" file systems are now mounted.  Go ahead and swap
# to files now, since they will be residing in the critical file
# systems (or, at least, better).
swapctl -A -t noblk

# clean up left-over files
rm -f /etc/nologin
rm -f /var/spool/lock/LCK.*
rm -f /var/spool/uucp/STST/*
(cd /var/run && { rm -rf -- *; install -c -m 664 -g utmp /dev/null utmp; })

# start the system logger first, so that all messages
# from daemons are logged, and the name server next.

if [ "$syslogd_flags" != NO ]; then
	if [ "$syslogd_flags" = DEFAULT ]; then
		syslogd_flags=""
	fi
	echo 'starting system logger'
	rm -f /dev/log
	syslogd $syslogd_flags
fi

if [ "$named_flags" != NO ]; then
	if [ "$named_flags" = DEFAULT ]; then
		named_flags=""
	fi
	echo 'starting name server';	named $named_flags
fi

# now start the rpc servers, for YP server/client, NFS.
echo -n 'starting rpc daemons:'

# note that portmap is generally required for all other rpc services.
if [ "$portmap" != NO ]; then
	echo -n ' portmap';             portmap
fi

if [ "$ypserv_flags" != NO ]; then
	if [ "$ypserv_flags" = DEFAULT ]; then
		ypserv_flags="-d"
	fi
        echo -n ' ypserv';              ypserv $ypserv_flags
fi

if [ "$ypbind_flags" != NO ]; then
	if [ "$ypbind_flags" = DEFAULT ]; then
		ypbind_flags=""
	fi
        echo -n ' ypbind';              ypbind $ypbind_flags
fi

if [ "$yppasswdd_flags" != NO ]; then
	if [ "$yppasswdd_flags" = DEFAULT ]; then
		yppasswdd_flags=""
	fi
        echo -n ' rpc.yppasswdd';       rpc.yppasswdd $yppasswdd_flags
fi

if [ "$bootparamd_flags" != NO ] && [ -r /etc/bootparams ]; then
	if [ "$bootparamd_flags" = DEFAULT ]; then
		bootparamd_flags=""
	fi
        echo -n ' rpc.bootparamd';      rpc.bootparamd $bootparamd_flags
fi

nfs_locking=NO

if [ "$nfs_server" = YES ] && [ -r /etc/exports ]; then
	if [ "$mountd_flags" = DEFAULT ]; then
		mountd_flags=""
	fi
        rm -f /var/db/mountdtab
        echo -n > /var/db/mountdtab
        echo -n ' mountd';              mountd $mountd_flags
	if [ "$nfsd_flags" = DEFAULT ]; then
		nfsd_flags="-tun 4"
	fi
        echo -n ' nfsd';                nfsd $nfsd_flags
	nfs_locking=MAYBE
fi

if [ "$nfs_client" = YES ]; then
	if [ "$nfsiod_flags" = DEFAULT ]; then
		nfsiod_flags="-n 4"
	fi
        echo -n ' nfsiod';              nfsiod $nfsiod_flags
	nfs_locking=MAYBE
fi

if [ "$nfs_locking" != NO ]; then
	if [ "$statd_flags" != NO ]; then
		if [ "$statd_flags" = DEFAULT ]; then
			statd_flags=""
		fi
		echo -n ' rpc.statd';		rpc.statd $statd_flags
	fi

	if [ "$lockd_flags" != NO ]; then
		if [ "$lockd_flags" = DEFAULT ]; then
			lockd_flags=""
		fi
		echo -n ' rpc.lockd';		rpc.lockd $lockd_flags
	fi
fi

if [ "$amd_flags" != NO ] && [ -d "$amd_dir" -a -r "$amd_master" ]; then
	if [ "$amd_flags" = DEFAULT ]; then
		amd_flags="-l syslog -x error,noinfo,nostats"
	fi
        echo -n ' amd'
        amd $amd_flags -p -a $amd_dir `cat $amd_master` > /var/run/amd.pid
fi

echo '.'
mount -a

if [ -f /sbin/ldconfig ]; then
	echo 'creating runtime link editor directory cache.'
	if [ -f /etc/ld.so.conf ]; then
		ldconfig `cat /etc/ld.so.conf`
	else
		ldconfig
	fi
fi 

# /var/crash should be a directory or a symbolic link
# to the crash directory if core dumps are to be saved.
if [ "$savecore_flags" != NO ] && [ -d /var/crash ]; then
	if [ "$savecore_flags" = DEFAULT ]; then
		savecore_flags=""
	fi
	echo checking for core dump...
	savecore $savecore_flags /var/crash
fi

				echo -n 'checking quotas:'
quotacheck -a
				echo ' done.'
quotaon -a

# build ps databases
echo 'building databases...'
kvm_mkdb /netbsd
dev_mkdb

chmod 666 /dev/tty[pqrs]*

# check the password temp/lock file
if [ -f /etc/ptmp ]
then
	logger -s -p auth.err \
	'password file may be incorrect -- /etc/ptmp exists'
fi

virecovery=/var/tmp/vi.recover/recover.*
if [ "$virecovery" != "/var/tmp/vi.recover/recover.*" ]; then
	echo preserving editor files
	for i in $virecovery; do
		sendmail -t < $i
	done
fi

echo clearing /tmp

# Prune quickly with one rm, then use find to clean up /tmp/[lq]* (this
# is not needed with mfs /tmp, but doesn't hurt anything).
(cd /tmp && rm -rf [a-km-pr-zA-Z]* &&
    find . ! -name . ! -name lost+found ! -name quota.user \
	! -name quota.group -exec rm -rf -- {} \; -type d -prune)

# Update kernel info in /etc/motd
# Must be done *before* interactive logins are possible to prevent
# possible race conditions.
if [ "$update_motd" != NO ]; then
	echo 'updating motd.'
	if [ ! -f /etc/motd ]; then
		install -c -o root -g wheel -m 664 /dev/null /etc/motd
	fi
	T=/tmp/_motd
	rm -f $T
	sysctl -n kern.version | sed 1q > $T
	echo "" >> $T
	sed '1,/^$/d' < /etc/motd >> $T
	cmp -s $T /etc/motd || cp $T /etc/motd
	rm -f $T
fi

if [ -f /var/account/acct ]; then
	echo 'turning on accounting';	accton /var/account/acct
fi

echo -n standard daemons:
if [ "$update_flags" != NO ]; then
	if [ "$update_flags" = DEFAULT ]; then
		update_flags="30"
	fi
	echo -n ' update';		update $update_flags
fi
echo -n ' cron';		cron
echo '.'

# now start all the other daemons
echo -n starting network daemons:

if [ "$gated_flags" != NO ] && [ -r /etc/gated.conf ]; then
	if [ "$gated_flags" = DEFAULT ]; then
		gated_flags=""
	fi
	echo -n ' gated';		gated $gated_flags
elif [ "$routed_flags" != NO ]; then
	if [ "$routed_flags" = DEFAULT ]; then
		routed_flags="-q"
	fi
	echo -n ' routed';		routed $routed_flags
fi

if [ "$mrouted_flags" != NO ]; then
	if [ "$mrouted_flags" = DEFAULT ]; then
		mrouted_flags=""
	fi
	echo -n ' mrouted';		mrouted $mrouted_flags
fi

if [ "$timed_flags" != NO ]; then
	if [ "$timed_flags" = DEFAULT ]; then
		timed_flags=""
	fi
	echo -n ' timed'; 		timed $timed_flags
fi

if [ "$ntpdate_hosts" != NO ]; then
	if [ "$ntpdate_hosts" = DEFAULT ]; then
		ntpdate_hosts=`awk '/^server/ {print $2}' </etc/ntp.conf`
	fi

	if [ -n "$ntpdate_hosts"  ]; then
		echo -n 'ntpdate:'
		ntpdate -b $ntpdate_hosts
	fi
fi

if [ "$xntpd_flags" != NO ]; then
	if [ "$xntpd_flags" = DEFAULT ]; then
		xntpd_flags="-p /var/run/xntpd.pid"
	fi
	echo -n ' xntpd';		xntpd $xntpd_flags
fi

if [ "$dhcpd_flags" != NO ] && [ -r /etc/dhcpd.conf ]; then
	if [ "$dhcpd_flags" = DEFAULT ]; then
		dhcpd_flags=""
	fi
	echo -n ' dhcpd';		dhcpd $dhcpd_flags
fi

if [ "$rwhod" = YES ]; then
	echo -n ' rwhod';		rwhod
fi

if [ "$lpd_flags" != NO ]; then
	if [ "$lpd_flags" = DEFAULT ]; then
		lpd_flags=""
	fi
	echo -n ' printer';		lpd $lpd_flags
fi

# We call sendmail with a full path so that SIGHUP works.
if [ "$sendmail_flags" != NO ] && [ -r /etc/sendmail.cf ]; then
	if [ "$sendmail_flags" = DEFAULT ]; then
		sendmail_flags="-bd -q30m"
	fi
	echo -n ' sendmail';		/usr/sbin/sendmail $sendmail_flags
fi

if [ "$rarpd_flags" != NO ] && [ -r /etc/ethers ]; then
	if [ "$rarpd_flags" = DEFAULT ]; then
		rarpd_flags="-a"
	fi
	echo -n ' rarpd';		rarpd $rarpd_flags
fi

if [ "$rbootd_flags" != NO ] && [ -r /etc/rbootd.conf ]; then
	if [ "$rbootd_flags" = DEFAULT ]; then
		rbootd_flags=""
	fi
	echo -n ' rbootd';		rbootd $rbootd_flags
fi

if [ "$mopd_flags" != NO ]; then
	if [ "$mopd_flags" = DEFAULT ]; then
		mopd_flags="-a"
	fi
	echo -n ' mopd';		mopd $mopd_flags
fi

if [ "$inetd_flags" != NO ] && [ -r /etc/inetd.conf ]; then
	if [ "$inetd_flags" = DEFAULT ]; then
		inetd_flags=""
	fi
	echo -n ' inetd';		inetd $inetd_flags
fi

echo '.'

# Kerberos runs ONLY on the Kerberos server machine
if [ "$kerberos_server" = YES ]; then
	echo -n 'starting kerberos daemons:'
	echo -n ' kerberos';	kerberos >> /var/log/kerberos.log &
	echo -n ' kadmind';	kadmind -n >> /var/log/kadmind.log &
	echo '.'
fi

. /etc/rc.local

date
exit 0
