#	$NetBSD: parselist.awk,v 1.1 2002/02/03 15:24:43 lukem Exp $
#
# Copyright (c) 2002 The NetBSD Foundation, Inc.
# All rights reserved.
#
# This code is derived from software contributed to The NetBSD Foundation
# by Luke Mewburn of Wasabi Systems.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
# 3. All advertising materials mentioning features or use of this software
#    must display the following acknowledgement:
#        This product includes software developed by the NetBSD
#        Foundation, Inc. and its contributors.
# 4. Neither the name of The NetBSD Foundation nor the names of its
#    contributors may be used to endorse or promote products derived
#    from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
# ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# awk -f parselist.awk -v mode=MODE file1 [...]
#
#	Parse list files file1 [...], generating different output,
#	depending upon the setting of MODE:
#	    crunch	crunchgen(1) config
#	    mtree	mtree(8) specfile
#	    populate	sh(1) commands to populate ${TARGDIR} from ${CURDIR}
#
# 	Each line of the input is either a comment (starts with `#'),
#	or contains one of the following keywords and arguments.
#	In general, keywords in lowercase are crunchgen(1) keywords which
#	might be also supported for the other operations.
#
#	mode key	operation
#	--------	---------
#	C		crunch
#	M		mtree
#	P		populate
#
#	mode	keyword arg1 [...]	description
#	----	------------------	-----------
#
#	C	ARGVLN	prog link	as per crunchgen(1) `ln'
#
#	P	CMD	arg1 [...]	run CMD as a shell command
#
#	M P	COPY	src dest	copy src to dest
#
#	C	LIBS	libspec ...	as per crunchgen(1) `libs'
#
#	M P	LINK	src d1 [d2 ...]	hard link src to d1, d2, ...
#
#	C M P	PROG	prog [links...]	program(s) to crunch/mtree/populate.
#					for M and P, the first prog listed
#					is copied from ${OBJDIR}/${CRUNCHBIN}
#					and then used as the name to link
#					all other PROG entries to.
#
#	C	SPECIAL	prog cmd ...	as per crunchgen(1) `special'
#
#	C	SRCDIRS	dirname ...	as per crunchgen(1) `srcdirs'
#
#	M P	SYMLINK src dest [...]	symlink src to dest, [...]
#

BEGIN \
{
	crunchprog = "";

	if (mode != "crunch" && mode != "mtree" && mode != "populate") {
		printf("Unknown parselist mode '%s'\n", mode) > "/dev/stderr";
		exit 1;
	}
	print "#";
	print "# This file is automatically generated by";
	print "#\tparselist mode=" mode;
	print "#";
	print "";
	if (mode == "populate") {
		print "checkvarisset()";
		print "{";
		print "	eval _v=\\$${1}";
		print "	if [ -z \"$_v\" ]; then";
		print "		echo 1>&2 \"Error: $1 is not defined\"";
		print "		exit 1";
		print "	fi";
		print "}";
		print;
		print "checkvarisset CURDIR";
		print "checkvarisset TARGDIR";
		print "checkvarisset OBJDIR";
		print "checkvarisset CRUNCHBIN";
		print "cd ${CURDIR}";
		print;
	} else if (mode == "mtree") {
		print "/unset\tmode";
		print "/set\ttype=file uname=root gname=wheel";
		print;
	}
}

/^$/ || /^#/ \
{
	print;
	next;
}

$1 == "COPY" \
{
	if (mode == "populate" || mode == "mtree")
		copy($2, $3);
	next;
}

$1 == "LIBS" || $1 == "SPECIAL" || $1 == "SRCDIRS" \
{
	if (mode == "crunch") {
		$1 = tolower($1);
		print;
	}
	next;
}

$1 == "PROG" \
{
	if (mode == "crunch") {
		prog = basename($2);
		print "progs " prog;
		for (i = 3; i <= NF; i++)
			print "ln " prog " " basename($i);
	} else {
		for (i = 2; i <= NF; i++) {
			if (crunchprog == "") {
				crunchprog = $i;
				copy("${OBJDIR}/${CRUNCHBIN}", crunchprog);
				continue;
			}
			link(crunchprog, $i);
		}
	}
	next;
}

$1 == "ARGVLN" \
{
	if (mode == "crunch") {
		$1 = "ln";
		print;
	}
	next;
}

$1 == "LINK" \
{
	if (mode == "populate" || mode == "mtree") {
		for (i = 3; i <= NF; i++)
			link($2, $i);
	}
	next;
}

$1 == "SYMLINK" \
{
	if (mode == "populate" || mode == "mtree") {
		for (i = 3; i <= NF; i++)
			symlink($2, $i);
	}
	next;
}

$1 == "CMD" \
{
	if (mode == "populate") {
		printf("(cd ${TARGDIR};");
		for (i = 2; i <= NF; i++)
			printf(" %s", $i);
		print ")";
	}
	next;
}

{
	printf("Unknown keyword '%s' at line %d of input.\n", $1, NR) \
	    >"/dev/stderr";
	exit 1;
}


function basename (file) \
{
	gsub(/[^\/]+\//, "", file);
	return file;
}

function copy (src, dest) \
{
	if (mode == "mtree") {
		printf("./%s\n", dest);
	} else {
		printf("rm -rf ${TARGDIR}/%s\n", dest);
		printf("cp %s ${TARGDIR}/%s\n", src, dest);
	}
}

function link (src, dest) \
{
	if (mode == "mtree") {
# XXX		printf("./%s type=hlink link=%s\n", dest, src);
		printf("./%s\n", dest);
	} else {
		printf("rm -rf ${TARGDIR}/%s\n", dest);
		printf("(cd ${TARGDIR}; ln %s %s)\n", src, dest);
	}
}

function symlink (src, dest) \
{
	if (mode == "mtree") {
		printf("./%s type=link link=%s\n", dest, src);
	} else {
		printf("rm -rf ${TARGDIR}/%s\n", dest);
		printf("(cd ${TARGDIR}; ln -s %s %s)\n", src, dest);
	}
}
