#!/bin/sh
#
# Print out the files in some or all lists.
# Usage: makeplist [-a arch] [-m machine] [-s setsdir] [-p prefix] setname pkgname
#

# set defaults
for x in $(
${MAKE:-make} -f- all <<EOF
.include <bsd.own.mk>
all:
	@echo machine=\${MACHINE}
	@echo machine_arch=\${MACHINE_ARCH}
	@echo machine_cpu=\${MACHINE_CPU}
	@echo object_fmt=\${OBJECT_FMT}
	@echo toolchain_missing=\${TOOLCHAIN_MISSING}
.if defined(USE_XF86_4) && (\${USE_XF86_4} != no)
	@echo x11_version=4
.else
	@echo x11_version=3
.endif

EOF
); do
	eval $x
done

. ./sets.subr
setd=`dirname $0`
prefix=/

usage() {
exec 1>&2

echo "Usage: $0 [-a arch] [-m machine] [-s setsdir] [-p prefix] setname pkgname"
echo "	-a arch		set arch (e.g, m68k, mips, powerpc)	[$machine_arch]"
echo "	-m machine	set machine (e.g, amiga, i386, macppc)	[$machine]"
echo "	-s setsdir	directory to find sets			[$setd]"
echo "	-p prefix	prefix for created plist		[$prefix]"
echo "	setname pkgname	set and package to build plist for"

exit 1
}

# handle args
while : ; do
	case $1 in
	-a*)
		machine_arch=$2; shift
		;;
	-m*)
		machine=$2; shift
		;;
	-s*)
		setd=$2; shift
		;;
	-p*)
		prefix=$2; shift
		;;
	-*)
		usage
		;;
	*)
		break
		;;
	esac
	shift
done
if [ -n "$1" ]; then
	setname="$1"
else
	usage
fi
if [ -n "$2" ]; then
	pkgname=$2
else
	usage
fi

# Determine lib type.
if [ "$object_fmt" = "ELF" ]; then
	shlib=elf
else
	shlib=aout
fi
stlib=$shlib

# Turn off shlibs for some ports.
if [ "$machine_cpu" = "sh3" -o "$machine_arch" = "m68000" ]; then
	shlib=no
fi
lkm=yes
# Turn off LKMs for some ports.
if [ "$machine" = "evbppc" ]; then
	lkm=no
fi

filename=/tmp/makeplist.$$ 
ffilename=/tmp/makeplist.files.$$ 
dfilename=/tmp/makeplist.dirs.$$ 

list_set_files $setname | \
env PLISTPKG=$pkgname awk -- '/^#/ { next } $2 == ENVIRON["PLISTPKG"] {sub("^\./", "", $1); print $1}' | sort -u > $filename

SELECTDIRS="-maxdepth 0 -type d"
SELECTNONDIRS="-maxdepth 0 ! -type d"

cd $prefix
#
# match the directories
#
xargs echo $SELECTDIRS < $filename | \
while read ignore ignore ignore ignore args; do
	[ -z "$args" ] && break 
	find $args $SELECTDIRS
done | awk '{ print "@dirrm " $1; }' > $dfilename

#
# match the non-directories
#
xargs echo $SELECTNONDIRS < $filename | \
while read ignore ignore ignore ignore ignore args; do
	[ -z "$args" ] && break 
	find $args $SELECTNONDIRS
done > $ffilename

cd -

echo "@cwd $prefix"
if [ -s $ffilename ]; then
	cat $ffilename
fi
if [ -s $dfilename ]; then
        sort -r $dfilename
fi

rm -f $filename $ffilename $dfilename

exit 0

