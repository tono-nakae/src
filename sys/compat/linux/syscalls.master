	$NetBSD: syscalls.master,v 1.8 1995/08/14 01:27:56 mycroft Exp $

;	@(#)syscalls.master	8.1 (Berkeley) 7/19/93

; NetBSD COMPAT_LINUX system call name/number "master" file.
; (See syscalls.conf to see what it is processed into.)
;
; Fields: number type [type-dependent ...]
;	number	system call number, must be in order
;	type	one of STD, OBSOL, UNIMPL, NODEF, NOARGS, or one of
;		the compatibility options defined in syscalls.conf.
;
; types:
;	STD	always included
;	OBSOL	obsolete, not included in system
;	UNIMPL	unimplemented, not included in system
;	NODEF	included, but don't define the syscall number
;	NOARGS	included, but don't define the syscall args structure
;
; The compat options are defined in the syscalls.conf file, and the
; compat option name is prefixed to the syscall name.  Other than
; that, they're like NODEF (for 'compat' options), or STD (for
; 'libcompat' options).
;
; The type-dependent arguments are as follows:
; For STD, NODEF, NOARGS, and compat syscalls:
;	{ pseudo-proto } [alias]
; For other syscalls:
;	[comment]
;
; #ifdef's, etc. may be included, and are copied to the output files.
; #include's are copied to the syscall switch definition file only.

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/signal.h>
#include <sys/mount.h>
#include <sys/syscallargs.h>
#include <compat/linux/linux_types.h>
#include <compat/linux/linux_signal.h>
#include <compat/linux/linux_syscallargs.h>
#include <machine/linux_machdep.h>

0	NOARGS		{ int nosys(void); } syscall
1	NOARGS		{ int exit(int rval); }
2	STD		{ int linux_fork(void); }
3	NOARGS		{ int read(int fd, char *buf, u_int nbyte); }
4	NOARGS		{ int write(int fd, char *buf, u_int nbyte); }
5	STD		{ int linux_open(char *path, int flags, int mode); }
6	NOARGS		{ int close(int fd); }
7	STD		{ int linux_waitpid(int pid, int *status, int options);}
8	STD		{ int linux_creat(char *path, int mode); }
9	NOARGS		{ int link(char *path, char *link); }
10	STD		{ int linux_unlink(char *path); }
11	STD		{ int linux_execve(char *path, char **argp, char **envp); }
12	STD		{ int linux_chdir(char *path); }
13	STD		{ int linux_time(linux_time_t *t); }
14	STD		{ int linux_mknod(char *path, int mode, int dev); }
15	STD		{ int linux_chmod(char *path, int mode); }
16	STD		{ int linux_chown(char *path, int uid, int gid); }
17	STD		{ int linux_break(char *nsize); }
18	OBSOL		linux_ostat
19	NOARGS		{ long compat_43_lseek(int fd, long offset, int whence); }
20	NOARGS		{ pid_t getpid(void); }
21	UNIMPL		linux_mount
22	UNIMPL		linux_umount
23	NOARGS		{ int setuid(uid_t uid); }
24	NOARGS		{ uid_t getuid(void); }
25	UNIMPL		linux_stime
26	UNIMPL		linux_ptrace
27	STD		{ int linux_alarm(unsigned int secs); }
28	OBSOL		linux_ofstat
29	STD		{ int linux_pause(void); }
30	STD		{ int linux_utime(char *path, struct linux_utimbuf *times); }
31	UNIMPL		linux_stty
32	UNIMPL		linux_gtty
33	STD		{ int linux_access(char *path, int flags); }
34	UNIMPL		linux_nice
35	UNIMPL		linux_ftime
36	NOARGS		{ int sync(void); }
37	STD		{ int linux_kill(int pid, int signum); }
38	STD		{ int linux_rename(char *from, char *to); }
39	STD		{ int linux_mkdir(char *path, int mode); }
40	STD		{ int linux_rmdir(char *path); }
41	NOARGS		{ int dup(u_int fd); }
42	STD		{ int linux_pipe(int *pfds); }
43	STD		{ int linux_times(struct times *tms); }
44	UNIMPL		linux_prof
45	STD		{ int linux_brk(char *nsize); }
46	NOARGS		{ int setgid(uid_t gid); }
47	NOARGS		{ gid_t getgid(void); }
48	STD		{ int linux_signal(int sig, linux_handler_t handler); }
49	NOARGS		{ uid_t geteuid(void); }
50	NOARGS		{ gid_t getegid(void); }
51	NOARGS		{ int acct(char *path); }
52	UNIMPL		linux_phys
53	UNIMPL		linux_lock
54	STD		{ int linux_ioctl(int fd, u_long com, caddr_t data); }
55	STD		{ int linux_fcntl(int fd, int cmd, void *arg); }
56	UNIMPL		linux_mpx
57	NOARGS		{ int setpgid(int pid, int pgid); }
58	UNIMPL		linux_ulimit
59	UNIMPL		linux_oldolduname
60	NOARGS		{ int umask(int newmask); }
61	NOARGS		{ int chroot(char *path); }
62	UNIMPL		linux_ustat
63	NOARGS		{ int dup2(u_int from, u_int to); }
64	NOARGS		{ pid_t getppid(void); }
65	NOARGS		{ int getpgrp(void); }
66	NOARGS		{ int setsid(void); }
67	STD		{ int linux_sigaction(int signum, \
				struct linux_sigaction *nsa,\
				struct linux_sigaction *osa); }
68	STD		{ int linux_siggetmask(void); }
69	STD		{ int linux_sigsetmask(linux_sigset_t mask); }
70	NOARGS		{ int compat_43_setreuid(int ruid, int euid); }
71	NOARGS		{ int compat_43_setregid(int rgid, int egid); }
72	STD		{ int linux_sigsuspend(caddr_t restart, int oldmask, \
				int mask); }
73	STD		{ int linux_sigpending(linux_sigset_t *mask); }
74	NOARGS		{ int compat_43_sethostname(char *hostname, u_int len);}
75	NOARGS		{ int compat_43_setrlimit(u_int which, \
				struct ogetrlimit *rlp); }
76	NOARGS		{ int compat_43_getrlimit(u_int which, \
				struct ogetrlimit *rlp); }
77	NOARGS		{ int getrusage(int who, struct rusage *rusage); }
78	NOARGS		{ int gettimeofday(struct timeval *tp, \
				struct timezone *tzp); }
79	NOARGS		{ int settimeofday(struct timeval *tp, \
				struct timezone *tzp); }
80	NOARGS		{ int getgroups(u_int gidsetsize, gid_t *gidset); }
81	NOARGS		{ int setgroups(u_int gidsetsize, gid_t *gidset); }
82	STD		{ int linux_select(struct linux_select *lsp); }
83	STD		{ int linux_symlink(char *path, char *to); }
84	NOARGS		{ int compat_43_lstat(char *path, struct ostat *up); }
85	STD		{ int linux_readlink(char *name, char *buf, int count); }
86	STD		{ int linux_uselib(char *path); }
87	NOARGS		{ int swapon(char *name); }
88	NOARGS		{ int reboot(int opt); }
89	STD		{ int linux_readdir(int fd, struct linux_dirent *dent, \
			    unsigned int count); }
90	STD		{ int linux_mmap(struct linux_mmap *lmp); }
91	NOARGS		{ int munmap(caddr_t addr, int len); }
92	STD		{ int linux_truncate(char *path, long length); }
93	NOARGS		{ int compat_43_ftruncate(int fd, long length); }
94	NOARGS		{ int fchmod(int fd, int mode); }
95	NOARGS		{ int fchown(int fd, int uid, int gid); }
96	NOARGS		{ int getpriority(int which, int who); }
97	NOARGS		{ int setpriority(int which, int who, int prio); }
98	NOARGS		{ int profil(caddr_t samples, u_int size, \
				u_int offset, u_int scale); }
99	STD		{ int linux_statfs(char *path, struct linux_statfs *sp); }
100	STD		{ int linux_fstatfs(int fd, struct linux_statfs *sp); }
101	UNIMPL		linux_ioperm
102	STD		{ int linux_socketcall(int what, void *args); }
103	UNIMPL		linux_klog
104	NOARGS		{ int setitimer(u_int which, struct itimerval *itv, \
			    struct itimerval *oitv); }
105	NOARGS		{ int getitimer(u_int which, struct itimerval *itv); }
106	STD		{ int linux_stat(char *path, struct linux_stat *sp); }
107	STD		{ int linux_lstat(char *path, struct linux_stat *sp); }
108	STD		{ int linux_fstat(int fd, struct linux_stat *sp); }
109	UNIMPL		linux_olduname
110	UNIMPL		linux_iopl
111	UNIMPL		linux_vhangup
112	UNIMPL		linux_idle
113	UNIMPL		linux_vm86
114	STD		{ int linux_wait4(int pid, int *status, int options, \
				struct rusage *rusage); }
115	UNIMPL		linux_swapoff
116	UNIMPL		linux_sysinfo
117	STD		{ int linux_ipc(int what, int a1, int a2, int a3, \
				caddr_t ptr); }
118	NOARGS		{ int fsync(int fd); }
119	STD		{ int linux_sigreturn(struct linux_sigcontext *scp); }
120	UNIMPL		linux_clone
121	NOARGS		{ int compat_09_setdomainname(char *name, int len); }
122	STD		{ int linux_uname(struct linux_utsname *up); }
#ifdef __i386__
123	STD		{ int linux_modify_ldt(int func, void *ptr, \
				size_t bytecount); }
#else
123	UNIMPL		linux_modify_ldt
#endif
124	UNIMPL		linux_adjtimex
125	NOARGS		{ int mprotect(caddr_t addr, int len, int prot); }
126	STD		{ int linux_sigprocmask(int how, linux_sigset_t *set, \
				linux_sigset_t *oset); }
127	UNIMPL		linux_create_module
128	UNIMPL		linux_init_module
129	UNIMPL		linux_delete_module
130	UNIMPL		linux_get_kernel_syms
131	UNIMPL		linux_quotactl
132	STD		{ int linux_getpgid(int pid); }
133	NOARGS		{ int fchdir(int fd); }
134	UNIMPL		linux_bdflush
135	UNIMPL		linux_sysfs
136	STD		{ int linux_personality(int per); }
137	UNIMPL		linux_afs_syscall
138	UNIMPL		linux_setfsuid
139	UNIMPL		linux_getfsuid
140	STD		{ int linux_llseek(int fd, u_int32_t ohigh, \
				u_int32_t olow, caddr_t res, int whence); }
