/*	$NetBSD: start_bootsect.S,v 1.19 2003/02/01 14:48:18 dsl Exp $	*/
	
/*
 * BIOS bootsector startup
 * parts from netbsd:sys/arch/i386/boot/start.S
 * and freebsd:sys/i386/boot/biosboot/boot2.S
 */

/*
 * Ported to boot 386BSD by Julian Elischer (julian@tfs.com) Sept 1992
 *
 * Mach Operating System
 * Copyright (c) 1992, 1991 Carnegie Mellon University
 * All Rights Reserved.
 * 
 * Permission to use, copy, modify and distribute this software and its
 * documentation is hereby granted, provided that both the copyright
 * notice and this permission notice appear in all copies of the
 * software, derivative works or modified versions, and any portions
 * thereof, and that both notices appear in supporting documentation.
 * 
 * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS "AS IS"
 * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR
 * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.
 * 
 * Carnegie Mellon requests users of this software to return to
 * 
 *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU
 *  School of Computer Science
 *  Carnegie Mellon University
 *  Pittsburgh PA 15213-3890
 * 
 * any improvements or extensions that they make and grant Carnegie Mellon
 * the rights to redistribute these changes.
 */

/*
  Copyright 1988, 1989, 1990, 1991, 1992 
   by Intel Corporation, Santa Clara, California.

                All Rights Reserved

Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby
granted, provided that the above copyright notice appears in all
copies and that both the copyright notice and this permission notice
appear in supporting documentation, and that the name of Intel
not be used in advertising or publicity pertaining to distribution
of the software without specific, written prior permission.

INTEL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE
INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS,
IN NO EVENT SHALL INTEL BE LIABLE FOR ANY SPECIAL, INDIRECT, OR
CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT,
NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

#include <machine/asm.h>
#include <machine/disklabel.h>

#include "bbinfo.h"

/* This code is read to 0x7c00 by the mbr (sector 0) code.
 * It is, however, linked to address 0.  So %cs and %ds are set to 0x7c0
 * so that everything works.
 * Because the mbr only reads in the first sector, so this code has to locate
 * the netbsd (dos) partition and read in a larger chunk of code from the
 * first few sectors (still not all the boot program) to address 0x10000.
 * This gives enough code that the rest of the boot program can be read
 * using the list of filestore block/length pairs generated by
 * /usr/mdec/installboot.
 * The C code will use buffers with 32bit addresses above 64k (ie physical
 * addresses above 128k)
 * The stack is also placed above 64k - so %ss != %cs in real mode.
 * The fact that we have 32bit code running with non-zero segments is,
 * at least at first, somewhat confusing...
 */

#define	BOOTSEG		0x1000		/* boot is loaded here (below 640K) */
#ifdef STACK_START
#define STACKSEG	((STACK_START/16) + BOOTSEG)
#endif
STACKOFF	=	0xfffc
LOADSZ		=	PRIM_LOADSZ	# size of first loaded chunk

SIGNATURE	=	0xaa55
PARTSTART	=	MBR_PARTOFF	# starting address of partition table
NUMPART		=	NMBRPART	# number of entries in partition table
PARTSZ		=	16		# sizeof(struct dos_partition)
NETBSDPART	=	MBR_PTYPE_NETBSD
#ifdef COMPAT_386BSD_MBRPART
OLDBSDPART	= 	MBR_PTYPE_386BSD
#endif
BOOTABLE	=	0x80		# dp_flag value for a bootable partition

	.text
	.code16
_C_LABEL(boot1):
ENTRY(start)

	/*
	 * XXX I have encountered at least one machine (a no-name laptop
	 * with an AMI WinBIOS) that will refuse to run the bootblock
	 * unless this short jump and nop are here. I'm not certain, but
	 * this may be a case of the BIOS performing some kind of simple
	 * virus detection.
	 * Or more likely just checking that there is code in it.
	 */
	jmp	start0
	nop
	.ascii	"NetBSD16"

	/* some BIOSs insist on patching the BPB, esp. on LS120 drives */
	/* dsl: I wonder whether they are patching a dos3.3 or dos5.0 bpb? */
	. = _C_LABEL(boot1) + 0x25

start0:
	# start (aka boot1) is loaded at 0x0:0x7c00 but we want 0x7c0:0
	# ljmp to the next instruction to adjust %cs
	ljmp	$0x7c0, $start1
start1:
	# set up %ds = %cs
	mov	%cs, %ax
	mov	%ax, %ds

	/*** set up %es, (where we will load boot2 to) ***/
	movw	$BOOTSEG, %ax
	mov	%ax, %es

	# set up %ss and %esp to be the top of bootseg
	# later we will move the stack 64k further up memory
	mov	%ax, %ss
	movl	$STACKOFF, %esp

	# bootstrap passes us drive number in %dl
	# we also might have a sector number in %esi
	cmpb	$0x80, %dl
	jae	hd

fd:
#	reset the disk system
	movb	$0x00, %ah
	int	$0x13
	movw	$1, %cx			# sector
	movb	$0x00, %dh		# head
	# XXX Override the drive number (dsl: why? floppy 1??).
	movb	$0x00, %dl
	pushl	$0			# sector # for next stage
	push	%dx
	jmp	load

hd:	/**** load sector 0 (DOSBBSECTOR) into the BOOTSEG ****/
	movw	$0x0201, %ax
	xor	%bx, %bx		# %bx = 0, buffer is es:%bx
	movw	$0x0001, %cx		# track 0, sector 1
	xorb	%dh,%dh			# dh = head = 0
	int	$0x13
	jc	read_error

	/***# find the first NetBSD partition *****/
	movb	$NETBSDPART, %al
scan_again:
	movw	$PARTSTART, %bp		/* %es = %ss, so %bp defaults to %es */
	movw	$NUMPART, %cx
1:
	cmpb    4(%bp), %al		/* dp_typ */
	jne	2f			/* jump if wrong type */
	testl	%esi,%esi		/* expecting a sector # match? */
	je	found			/* jump if not */
	cmpl	8(%bp), %esi		/* start sector */
	je	found
2:	addw	$PARTSZ, %bp
	loop	1b

	testl	%esi,%esi
	je	3f
	xor	%esi,%esi
	jmp	scan_again

3:
#ifdef COMPAT_386BSD_MBRPART
	/* didn't find a NetBSD partition, look for a 386BSD one */
	cmpb	$NETBSDPART,%al
	jne	4f
	movb	$OLDBSDPART,%al
	jmp	scan_again
4:
#endif

	/* didn't find either NetBSD or 386BSD partitions */
noboot:
	movw	$enoboot, %si
	jmp	err_stop


found:
	pushl	8(%bp)			/* Sector # for next stage */
/*
 * See if we night need int13 extensions. Compute the total number
 * of CHS addressable sectors, and compare them to what we need
 * The reason to avoid int13 extensions as much as possible, is
 * that they're apparently buggy in some BIOSs.
 */
	push	%dx			/* save drive number */

	movb	$8,%ah
	int	$0x13

	shr	$8,%edx
	incl	%edx				/* dx now heads 1..256 */
	movb	%cl,%al
						/* we need eax[31:16] = 0 */
	andl    $0x3f,%eax			/* ax now sectors 1..63 */
	mull	%edx				/* ax = heads * sectors */
	xchg	%eax,%ecx			/* 32bit count in ecx */
	shrb	$6,%al
	xchgb	%al,%ah				/* 10 bit cyl in ax */
	incl	%eax				/* cylinders 1..1024 */
	cwde					/* extend ax into eax */
	mull	%ecx				/* sectors in eax */

	movl	8(%bp),%ebx
	addl	$LOADSZ+1, %ebx		/* ebx = maximum sector # we need */

	cmpl	%eax, %ebx
	pop	%dx
	jl	tradint13

/*
 * Ok, sector number is above CHS limit, see if int13 extensions
 * and LBA reads are supported.
 */

/*
 * BIOS call "INT 0x13 Function 0x41" to check for int13 extensions.
 *	Call with	%ah = 0x41
 *			%bx = 0x55aa
 *			%dl = drive (0x80 for hard disk)
 *	Return:
 *			%cf = clear on success, set on error
 *			%bx = 0xaa55
 *			%cx = API subset bitmap, &1 -> extended disk access
 */
	push	%dx
	movb	$0x41, %ah
	movw	$0x55aa, %bx
	int	$0x13
	pop	%dx
	jb	err_no_lba
	cmpw	$0xaa55, %bx
	jnz	err_no_lba
	testb	$1, %cl
	jz	err_no_lba

/*
 * BIOS call "INT 0x13 Function 0x42", extended read
 *	Call with	%ah = 0x42
 *			%dl = drive (0x80 for hard disk)
 *			%ds:%si = parameter:
 *				0: 0x10 (size of packet)
 *				1: 0
 *				2: number of sectors
 *				4: segment:offset of buffer
 *				8: block number (8 bytes)
 */

	push	%dx
	pushl	$0		/* high 4 bytes of sector = 0 */
	pushl	8(%bp)		/* low 4 bytes of sector */
	push	%es
	pushw	$0		/* ie address 0 in BOOTSEG */
	pushl	$0x10 + LOADSZ*0x20000
	movl	%esp, %esi
	push	%ss
	pop	%ds
	movb	$0x42, %ah
	int	$0x13
	push	%cs
	pop	%ds		/* reestablish %ds */
	addw	$16, %sp	/* ditch args */

	jmp	to_boot2

/*
 * BIOS call "INT 0x13 Function 0x2" to read sectors from disk into memory
 *	Call with       %ah = 0x2
 *			%al = number of sectors
 *			%ch = cylinder
 *			%cl = sector
 *			%dh = head
 *			%dl = drive (0x80 for hard disk, 0x0 for floppy disk)
 *			%es:%bx = segment:offset of buffer
 *	Return:
 *			%al = 0x0 on success; err code on failure
 */
tradint13:
	push	%dx
	movb	1(%bp), %dh	/* head: dp_sdh */
	movw	2(%bp), %cx	/* sect, cyl: dp_ssect + (dp_scyl << 8)*/

load:
	movb	$0x2, %ah	/* function 2 */
	movb	$LOADSZ, %al	/* number of blocks */
	xorw	%bx, %bx	/* %bx = 0, put it at 0 in the BOOTSEG */
	int	$0x13

to_boot2:
	pop	%dx
	jb	read_error

	# ljmp to the second stage boot loader (boot2).
	# After ljmp, %cs is BOOTSEG

	popl	%esi		/* sector number */
	ljmp	$BOOTSEG, $_C_LABEL(boot2)

/*
 * error reporting
 */
err_no_lba:
	movw	$elba, %si
	jmp	err_stop
read_error:
	movw	$eread, %si
err_stop:
	call	message
	cli
	hlt

#if 1
/* This is useful for debugging - although you may need to
 * delete some code to fit it in!
 * Doesn't really matter where SI points!
 */
ENTRY(dump_eax)
	pusha					/* saves bottom 16 bits only! */
	movw	$_C_LABEL(start), %si
	mov	%si, %di
	movw	$8, %cx
1:	roll	$4, %eax
	mov	%ax, %bx
	andb	$0x0f, %al
	addb	$0x30, %al			/* 30..3f - clear AF */
#if 1 /* 5 bytes to generate real hex... */
	daa					/* 30..39, 40..45 */
	addb	$0xc0, %al			/* f0..f9, 00..05 */
	adcb	$0x40, %al			/* 30..39, 41..45 */
#endif
	movb	%al,(%di)			/* %es != %ds, so can't ... */
	inc	%di				/* ... use stosb */
	mov	%bx, %ax
	loop	1b
	movw	$0x20, %ax			/* space + null */
	movw	%ax,(%di)
	jmp	message_1
#endif

/*
 * message: write the error message in %ds:%esi to the console
 */
ENTRY(message)
/*
 * BIOS call "INT 10H Function 0Eh" to write character to console
 *	Call with	%ah = 0x0e
 *			%al = character
 *			%bh = page
 *			%bl = foreground color
 */
	pusha
message_1:
1:
	cld
	lodsb			# load a byte into %al
	testb	%al, %al
	jz	2f

	movb	$0x0e, %ah
	movw	$0x0001, %bx
	int	$0x10

	jmp	1b

2:
	/* Delay for about 1 second to allow message to be read */
	movb	$0x86, %ah
	mov	$16, %cx		/* about a second */
	int	$0x15			/* delay cx:dx usecs */
	popa
	ret

eread:	.asciz		"Read error\r\n"
enoboot: .asciz		"No NetBSD partition\r\n"
elba:	.asciz		"LBA reads unsupported\r\n"

/* throw in a partition table in case we are block0 as well */
/* flag, head, sec, cyl, typ, ehead, esect, ecyl, start, len */
	. = _C_LABEL(boot1) + PARTSTART
	.byte	0x0,0,0,0,0,0,0,0
	.long	0,0
	.byte	0x0,0,0,0,0,0,0,0
	.long	0,0
	.byte	0x0,0,0,0,0,0,0,0
	.long	0,0
	.byte	BOOTABLE,0,1,0,NETBSDPART,0,16,0
	.long	0,16
/* the last 2 bytes in the sector 0 contain the signature */
	. = _C_LABEL(boot1) + 0x1fe
	.short	SIGNATURE

/* Leave space here (1 sector) for the NetBSD disklabel */
	. = _C_LABEL(boot1) + 0x200
	.globl	_C_LABEL(disklabel)
_C_LABEL(disklabel):

/* Now we have a bit more space to play with */
	. = _C_LABEL(boot1) + 0x400
ourseg:
	.long	0

/**************************************************************************
GLOBAL DESCRIPTOR TABLE
**************************************************************************/
#ifdef __ELF__
	.align	16
#else
	.align	4
#endif
gdt:
	.word	0, 0
	.byte	0, 0x00, 0x00, 0

#ifdef SUPPORT_LINUX	/* additional dummy */
	.word	0, 0
	.byte	0, 0x00, 0x00, 0
#endif

	/* kernel code segment */
	.globl flatcodeseg
flatcodeseg = . - gdt
	.word	0xffff, 0
	.byte	0, 0x9f, 0xcf, 0

	/* kernel data segment */
	.globl flatdataseg
flatdataseg = . - gdt
	.word	0xffff, 0
	.byte	0, 0x93, 0xcf, 0

	/* boot code segment, base will be patched */
bootcodeseg = . - gdt
	.word	0xffff, 0
	.byte	0, 0x9e, 0x4f, 0

	/* boot data segment, base will be patched */
bootdataseg = . - gdt
	.word	0xffff, 0
	.byte	0, 0x92, 0x4f, 0

	/* 16 bit real mode, base will be patched */
bootrealseg = . - gdt
	.word	0xffff, 0
	.byte	0, 0x9e, 0x00, 0
gdtlen = . - gdt

#ifdef __ELF__
	.align	16
#else
	.align	4
#endif
gdtarg:
	.word	gdtlen-1		/* limit */
	.long	0			/* addr, will be inserted */

/* NB this code isn't always called directly from the copy above.
  It is possible the code that loaded us came from a different
  partition.

  On entry dl is BIOS drive number, esi might be the sector number
*/
_C_LABEL(boot2):
	.code16
	xorl	%eax, %eax
	mov	%cs, %ax
	mov	%ax, %ds
	mov	%ax, %es
	movl	%eax, ourseg
	shll	$4, %eax

	/* fix up GDT entries for bootstrap */
#define FIXUP(gdt_index) \
	movw	%ax, gdt+gdt_index+2; \
	movb	%bl, gdt+gdt_index+4

	shldl	$16, %eax, %ebx

	FIXUP(bootcodeseg)
	FIXUP(bootrealseg)
	FIXUP(bootdataseg)

	/* fix up GDT pointer */
	addl	$gdt, %eax
	movl	%eax, gdtarg+2

#ifdef STACKSEG
	/* To give us more stack space (without overwriting the data)
	 * use a different 64k segment for the stack.
	 */
	mov	$STACKSEG, %ax
	mov	%ax, %ss
#endif

	/* change to protected mode */
	calll	_C_LABEL(real_to_prot)
	.code32

	pushl	%esi		/* sector where we found bootstrap */
	movzbl	%dl, %edx	/* discard head (%dh) and random high bits */
	pushl	%edx

	call	_C_LABEL(bootsectmain)
ENTRY(exit)
	call	_C_LABEL(prot_to_real)
	.code16
ENTRY(exit16)
	movw	$efail, %si
	call	message

#if	1
	/* call ROM BASIC */
	int	$0x18
#else
	cli
	hlt
#endif
efail:	.asciz		"Boot fail\r\n"

CR0_PE		=	0x1

/*
 * real_to_prot()
 * 	transfer from real mode to protected mode.
 * NB: Call with the 32bit calll instruction so that a 32 bit
 *     return address is pushed (using a 32bit %esp).
 */
ENTRY(real_to_prot)
	.code16
	pushl	%eax
	push	%cs			/* ensure %ds is correct */
	pop	%ds
	# guarantee that interrupt is disabled when in prot mode
	cli

	# load the gdtr
	lgdt	gdtarg

	# set the PE bit of CR0
	movl	%cr0, %eax

	orl	$CR0_PE, %eax
	movl	%eax, %cr0 

	# make intrasegment jump to flush the processor pipeline and
	# reload CS register
	ljmp	$bootcodeseg, $xprot

xprot:
	.code32
	# we are in USE32 mode now
	# set up the protected mode segment registers : DS, SS, ES
	movl	$bootdataseg, %eax
	mov	%ax, %ds
	mov	%ax, %es
	mov	%ax, %ss
#ifdef STACKSEG
	addl	$(STACKSEG - BOOTSEG)*16, %esp
#endif

	popl	%eax
	ret

/*
 * prot_to_real()
 * 	transfer from protected mode to real mode
 */
ENTRY(prot_to_real)
	.code32
	pushl	%eax
	# Adjust the intersegment jump instruction following 
	# the clearing of protected mode bit.
	# This is self-modifying code, but we need a writable
	# code segment, and an intersegment return does not give us that.

	movl	ourseg, %eax
	movw	%ax, xreal-2

	# Change to use16 mode.
	ljmp	$bootrealseg, $x16

x16:
	.code16
	# clear the PE bit of CR0
	movl	%cr0, %eax
	andl 	$~CR0_PE, %eax
	movl	%eax, %cr0
	ljmp	$0, $xreal		/* segment patched */

xreal:
	# we are in real mode now
	# set up the real mode segment registers : DS, SS, ES
	mov	%cs, %ax
	mov	%ax, %ds
	mov	%ax, %es
#ifdef STACKSEG
	mov	$STACKSEG, %ax
	mov	%ax, %ss
	subl	$(STACKSEG - BOOTSEG)*16, %esp
#else
	mov	%ax, %ss
#endif
	push	%bp
	movw	%sp, %bp
	/* check we are returning to an address below 64k */
	movw	2/*bp*/ + 4/*eax*/ + 2(%bp), %ax	/* high bits ret addr */
	test	%ax, %ax
	jne	1f
	pop	%bp

	sti
	popl	%eax
	retl

1:	movw	$2f, %si
	call	message
	movl	2/*bp*/ + 4/*eax*/(%bp), %eax		/*  return address */
	call	dump_eax
	jmp	exit16
2:	.asciz	"prot_to_real can't return to "

/*
 * pbzero(dst, cnt)
 *	where dst is a physical address and cnt is the length
 */
ENTRY(pbzero)
	.code32
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%es
	pushl	%edi

	cld

	# set %es to point at the flat segment
	movl	$flatdataseg, %eax
	mov	%ax, %es

	movl	8(%ebp), %edi		# destination
	movl	12(%ebp), %ecx		# count
	xorl	%eax, %eax		# value

	rep
	stosb

	popl	%edi
	popl	%es
	popl	%ebp
	ret

/*
 * vpbcopy(src, dst, cnt)
 *	where src is a virtual address and dst is a physical address
 */
ENTRY(vpbcopy)
	.code32
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%es
	pushl	%esi
	pushl	%edi

	cld

	# set %es to point at the flat segment
	movl	$flatdataseg, %eax
	mov	%ax, %es

	movl	8(%ebp), %esi		# source
	movl	12(%ebp), %edi		# destination
	movl	16(%ebp), %ecx		# count

	rep
	movsb

	popl	%edi
	popl	%esi
	popl	%es
	popl	%ebp
	ret

/*
 * pvbcopy(src, dst, cnt)
 *	where src is a physical address and dst is a virtual address
 */
ENTRY(pvbcopy)
	.code32
	pushl	%ebp
	movl	%esp, %ebp
	pushl	%ds
	pushl	%esi
	pushl	%edi

	cld

	# set %ds to point at the flat segment
	movl	$flatdataseg, %eax
	mov	%ax, %ds

	movl	8(%ebp), %esi		# source
	movl	12(%ebp), %edi		# destination
	movl	16(%ebp), %ecx		# count

	rep
	movsb

	popl	%edi
	popl	%esi
	popl	%ds
	popl	%ebp
	ret

/* vtophys(void *)
 * convert boot time 'linear' address to a physical one
 */

ENTRY(vtophys)
	.code32
	movl	ourseg, %eax
	shll	$4, %eax
	addl	4(%esp), %eax
	ret

#if 1
/* A couple of trivial trace routines it is (almost) always safe to call */

	.globl	_C_LABEL(trace_str)
_C_LABEL(trace_str):
	.code32
	movl	4(%esp), %eax
	pusha
	movl	%eax, %esi

	call	_C_LABEL(prot_to_real)
	.code16

	movl	%esi, %eax
	call	message

	calll	_C_LABEL(real_to_prot)
	.code32
	popa
	ret

	.globl	_C_LABEL(trace_int)
_C_LABEL(trace_int):
	.code32
	movl	4(%esp), %eax
	pusha

	call	_C_LABEL(prot_to_real)
	.code16

	call	dump_eax

	calll	_C_LABEL(real_to_prot)
	.code32
	popa
	ret
#endif
