*** spec_vnops.c.orig	Fri Jul  8 04:51:48 1994
--- spec_vnops.c	Fri Jul  8 04:52:44 1994
***************
*** 218,224 ****
   	struct proc *p = uio->uio_procp;
  	struct buf *bp;
  	daddr_t bn, nextbn;
! 	long bsize, bscale;
  	struct partinfo dpart;
  	int n, on, majordev, (*ioctl)();
  	int error = 0;
--- 218,224 ----
   	struct proc *p = uio->uio_procp;
  	struct buf *bp;
  	daddr_t bn, nextbn;
! 	long bsize, bscale, ssize;
  	struct partinfo dpart;
  	int n, on, majordev, (*ioctl)();
  	int error = 0;
***************
*** 246,261 ****
  		if (uio->uio_offset < 0)
  			return (EINVAL);
  		bsize = BLKDEV_IOSIZE;
  		dev = vp->v_rdev;
  		if ((majordev = major(dev)) < nblkdev &&
  		    (ioctl = bdevsw[majordev].d_ioctl) != NULL &&
! 		    (*ioctl)(dev, DIOCGPART, (caddr_t)&dpart, FREAD, p) == 0 &&
! 		    dpart.part->p_fstype == FS_BSDFFS &&
! 		    dpart.part->p_frag != 0 && dpart.part->p_fsize != 0)
! 			bsize = dpart.part->p_frag * dpart.part->p_fsize;
! 		bscale = bsize / DEV_BSIZE;
  		do {
! 			bn = (uio->uio_offset / DEV_BSIZE) &~ (bscale - 1);
  			on = uio->uio_offset % bsize;
  			n = min((unsigned)(bsize - on), uio->uio_resid);
  			if (vp->v_lastr + bscale == bn) {
--- 246,266 ----
  		if (uio->uio_offset < 0)
  			return (EINVAL);
  		bsize = BLKDEV_IOSIZE;
+ 		ssize = DEV_BSIZE;
  		dev = vp->v_rdev;
  		if ((majordev = major(dev)) < nblkdev &&
  		    (ioctl = bdevsw[majordev].d_ioctl) != NULL &&
! 		    (*ioctl)(dev, DIOCGPART, (caddr_t)&dpart, FREAD, p) == 0) {
! 			if (dpart.part->p_fstype == FS_BSDFFS &&
! 			    dpart.part->p_frag != 0 && dpart.part->p_fsize != 0)
! 				bsize = dpart.part->p_frag *
! 				    dpart.part->p_fsize;
! 			if (dpart.disklab->d_secsize != 0)
! 				ssize = dpart.disklab->d_secsize;
! 		}
! 		bscale = bsize / ssize;
  		do {
! 			bn = (uio->uio_offset / ssize) &~ (bscale - 1);
  			on = uio->uio_offset % bsize;
  			n = min((unsigned)(bsize - on), uio->uio_resid);
  			if (vp->v_lastr + bscale == bn) {
***************
*** 300,306 ****
  	struct proc *p = uio->uio_procp;
  	struct buf *bp;
  	daddr_t bn;
! 	int bsize, blkmask;
  	struct partinfo dpart;
  	register int n, on;
  	int error = 0;
--- 305,311 ----
  	struct proc *p = uio->uio_procp;
  	struct buf *bp;
  	daddr_t bn;
! 	int bsize, blkmask, ssize;
  	struct partinfo dpart;
  	register int n, on;
  	int error = 0;
***************
*** 327,342 ****
  		if (uio->uio_offset < 0)
  			return (EINVAL);
  		bsize = BLKDEV_IOSIZE;
  		if ((*bdevsw[major(vp->v_rdev)].d_ioctl)(vp->v_rdev, DIOCGPART,
  		    (caddr_t)&dpart, FREAD, p) == 0) {
  			if (dpart.part->p_fstype == FS_BSDFFS &&
  			    dpart.part->p_frag != 0 && dpart.part->p_fsize != 0)
  				bsize = dpart.part->p_frag *
  				    dpart.part->p_fsize;
  		}
! 		blkmask = (bsize / DEV_BSIZE) - 1;
  		do {
! 			bn = (uio->uio_offset / DEV_BSIZE) &~ blkmask;
  			on = uio->uio_offset % bsize;
  			n = min((unsigned)(bsize - on), uio->uio_resid);
  			if (n == bsize)
--- 332,350 ----
  		if (uio->uio_offset < 0)
  			return (EINVAL);
  		bsize = BLKDEV_IOSIZE;
+ 		ssize = DEV_BSIZE;
  		if ((*bdevsw[major(vp->v_rdev)].d_ioctl)(vp->v_rdev, DIOCGPART,
  		    (caddr_t)&dpart, FREAD, p) == 0) {
  			if (dpart.part->p_fstype == FS_BSDFFS &&
  			    dpart.part->p_frag != 0 && dpart.part->p_fsize != 0)
  				bsize = dpart.part->p_frag *
  				    dpart.part->p_fsize;
+ 			if (dpart.disklab->d_secsize != 0)
+ 				ssize = dpart.disklab->d_secsize;
  		}
! 		blkmask = (bsize / ssize) - 1;
  		do {
! 			bn = (uio->uio_offset / ssize) &~ blkmask;
  			on = uio->uio_offset % bsize;
  			n = min((unsigned)(bsize - on), uio->uio_resid);
  			if (n == bsize)
*** nfs_boot.c	Wed Jun 29 20:31:52 1994
--- /usr/src/sys/keep/nfs_boot.c	Fri Jul  8 21:57:14 1994
***************
*** 49,54 ****
--- 49,57 ----
  #include <nfs/nfs.h>
  #include <nfs/nfsdiskless.h>
  
+ #include "ether.h"
+ #if NETHER > 0
+ 
  /*
   * Support for NFS diskless booting, specifically getting information
   * about where to boot from, what pathnames, etc.
***************
*** 602,604 ****
--- 605,618 ----
  	m_freem(m);
  	return error;
  }
+ 
+ #else /* NETHER */
+ 
+ int nfs_boot_init(nd, procp)
+ 	struct nfs_diskless *nd;
+ 	struct proc *procp;
+ {
+ 	panic("nfs_boot_init: no ether");
+ }
+ 
+ #endif /* NETHER */
