#	$NetBSD: Makefile.rump,v 1.26 2009/01/10 20:19:43 pooka Exp $
#

WARNS?=		4
NOLINT=		# kernel code

.include <bsd.own.mk>

# use kernel ABI instead of rump ABI (needs md code)
.ifndef(RUMPKMOD)
CPPFLAGS:=	-I${RUMPTOP}/include ${CPPFLAGS}
.endif

CFLAGS+=	-ffreestanding -fno-strict-aliasing
CPPFLAGS+=	-D_RUMPKERNEL	# XXX: this should die
CPPFLAGS+=	-D_KERNEL -DMULTIPROCESSOR -D_MODULE -DMODULAR
CPPFLAGS+=	-DMAXUSERS=32
CPPFLAGS+=	-DDIAGNOSTIC
CPPFLAGS+=	-I${.CURDIR} -I.
CPPFLAGS+=	-I${RUMPTOP}/../../common/include -I${RUMPTOP}/../arch
CPPFLAGS+=	-I${RUMPTOP}/include
CPPFLAGS+=	-I${RUMPTOP}/librump/rumpkern/opt
CPPFLAGS+=	-nostdinc -I${RUMPTOP}/..
#CPPFLAGS+=	-DDEBUG

RUMPKERNEL=	This is NetBSD and I am the rump.  Good evening.

# workaround: evbppc is not a well-defined arch
.if (${MACHINE} == "evbppc")
CPPFLAGS+=	-DPPC_OEA
.endif

# If this file changes, we need a full rebuild
DPSRCS+=	${RUMPTOP}/Makefile.rump

#
# Rename library symbols before use.  If a symbol does not already belong
# to a rump namespace ("rump" or "RUMP"), prefix it with "rumpns".  This
# avoids accidentally linking any kernel symbol against host platform
# libraries.  The only non-renamed symbols are linkset delimiters and
# the GOT, which are more a property of the compiler than the kernel.
#

__archivebuild: .USE
	${_MKTARGET_BUILD}
	rm -f ${.TARGET}
	${AR} cq ${.TARGET} `NM=${NM} ${LORDER} ${.ALLSRC:M*o} | ${TSORT}`
.if ${MACHINE_CPU} != "mips" && ${MACHINE_CPU} != "sh3" \
 && ${MACHINE_CPU} != "arm" && ${MACHINE_CPU} != "sparc"
	${NM} -go ${.TARGET} | ${TOOL_AWK} '	\
	    $$NF!~/^(rump|RUMP|__(start|stop)_link_set|_GLOBAL_OFFSET_TABLE)/ \
	      {printf "%s rumpns_%s\n", $$NF, $$NF}' \
	    | sort | uniq  > renametab.${.TARGET}
	${OBJCOPY} --redefine-syms renametab.${.TARGET} ${.TARGET}
	rm -f renametab.${.TARGET}
.endif
	${RANLIB} ${.TARGET}
